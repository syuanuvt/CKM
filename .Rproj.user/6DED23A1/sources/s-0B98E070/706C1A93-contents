library(mbclusterwise)
library(flexmix)
library(combinat)
library(mclust)
library(ggplot2)
library(fpc)
library(iCluster)
library(ClusterSSCA)
library(PCovR)
library(dplyr)
library(pracma)
library(ggplot2)
library(GGally)
library(dplyr)
library(tidyr)
library(rARPACK)
library(RSpectra)
library(pracma)
library(psych)
library(combinat)

MatrixCenter <- function(matrix, center, scale){
  # matrix: the matrix that need to be centered and (or) scaled
  # center: does the matrix need to be centered (1 = Yes, 0 = No)
  # scaled: does the matrix need to be scaled (1 = Yes, 0 = No)
  
  variable_mean <- apply(matrix, 2, mean)
  variable_sd <- apply(matrix, 2, sd)
  n_observation <- nrow(matrix)
  
  if (center == 1){
    matrix <- matrix - rep(1, n_observation) %*% t(variable_mean)
  }
  if (scale == 1){
    matrix <- t(t(matrix) / variable_sd)
  }
  
  return(matrix)
}

#### congruence
tuckercongruence <- function(matrix1, matrix2){
  ## note that two matrices should be in the same size
  # matrix1: reference matrix
  # matrix2: matrix to compare to the reference
  
  m <- nrow(matrix1)
  n <- ncol(matrix2)
  
  indic_perms <- permn(1:n)
  tuck <- vector("numeric")
  for (i in 1:length(indic_perms)){
    matrix2_perm <- matrix2[ ,indic_perms[[i]]]
    tuck[i] <- tr(abs(factor.congruence(matrix1, matrix2_perm))) / n
  }
  
  tuck_max <- max(tuck)
  return (tuck_max)
}

### a list of congruence
paircongruence <- function(lista, listb, cluster_num){
  
  cong <- vector("numeric", length = cluster_num)
  for (i in 1:cluster_num){
    p <- 0
    cong_i <- vector("numeric", length = (cluster_num - 1))
    current <- lista[[i]]
    for (j in 1:cluster_num){
      p <- p + 1
      cong_i[p] <- tuckercongruence(current, listb[[j]])
    }
    cong[i] <- max(cong_i)
  }
  return (cong)
}

### add the noise to the dataset
Add <- function(inidata, cluster_assign, p_noise, p_mean){
  # inidata: the data generated via the covariance structure
  # p_noise: pencentage of noise
  
  n_row <- nrow(inidata)
  n_col <- ncol(inidata)
  n_cluster <- length(unique(cluster_assign))
  
  inidata <- MatrixCenter(inidata, 1, 0)
  finaldata <- matrix(nrow = n_row, ncol = n_col)
  finaldata <- inidata
  
  mean_data <- matrix(nrow = n_row, ncol = n_col)
  mean_cluster <- matrix(nrow = n_cluster, ncol = n_col)
  
  for (i in 1:n_cluster){
    mean_cluster[i, ] <- rnorm(n_col)
    mean_data[which(cluster_assign == i), ] <- rep(mean_cluster[i, ], each = sum(cluster_assign == i))
  }
  mean_data <- MatrixCenter(mean_data,1,0)
  
  if(n_col != 1){
    finaldata <- inidata + t(sqrt(p_mean * (1 - p_noise) / apply(mean_data, 2, function(x) mean(x^2))) * t(mean_data))
  }
  if(n_col == 1){
    finaldata <- inidata + sqrt(p_mean * (1 - p_noise) / mean(mean_data^2)) * mean_data
  }
  
  final_mean_data <- sqrt(p_mean * (1 - p_noise) / mean(mean_data^2)) * mean_data
  
  noise <- matrix(rnorm(n_row * n_col), n_row, n_col)
  if(n_col == 1){
    noise <- sqrt(p_noise/mean(noise^2)) * noise
  }
  if(n_col != 1){
    noise <- t(sqrt(p_noise/apply(noise,2,function(x) mean(x^2))) * t(noise))
  }
  finaldata <- finaldata + noise
  
  return (list(final_data = finaldata, noise = noise, final_mean_data = final_mean_data))
}

### obtain a random cluster assignment (typically as the first step)
RandomStart <- function(mem_cluster){
  #i: number of observations
  #ncluster: number of clusters
  #ncom: number of components
  #i <- 20
  #ncluster <- 4
  #set.seed(seed)
  
  i <- sum(mem_cluster)
  ncluster <- length(mem_cluster)
  
  mem.cluster <- matrix(0, nrow = i, ncol = ncluster)
  ind.cluster <- vector("numeric")
  
  # initialize
  for (t in 1:ncluster){
    ind.cluster <- c(ind.cluster, rep(t, mem_cluster[t]))
  }
  
  # randomlize
  ind.cluster <- sample(ind.cluster)
  
  # set to the membership cluster
  for (j in 1:i){
    mem.cluster[j, ind.cluster[j]] <- 1
  }
  
  return (list(mem = mem.cluster, ind = ind.cluster))
}

### obtain a semi-random cluster assignment (with a known partition)
SemiRandomStart <- function(start_part, num_exchange = 0){
  
  
  ncluster <- length(unique(start_part))
  nobs <- length(start_part)
  final_part <- start_part
  index <- 1:nobs
  if(num_exchange != 0 ){
    exchange.index <- sample(index, num_exchange, replace = FALSE)
  }
  if(num_exchange != 0 ){
    for (i in 1:num_exchange){
      if(ncluster != 2){
        ind <- exchange.index[i]
        current_cluster <- start_part[ind]
        new_cluster <- sample(setdiff(1:ncluster,current_cluster),1)
        final_part[ind] <- new_cluster
      }
      if(ncluster == 2){
        ind <- exchange.index[i]
        current_cluster <- start_part[ind]
        new_cluster <- setdiff(1:ncluster,current_cluster)
        final_part[ind] <- new_cluster
      }
    }
  }
  
  return (final_part)
}

######calculate the real partition of the observations
RealPar <- function(n_cluster, data_y,true_score,loading_y){
  
  n_obs <- length(data_y)
  res_y <- matrix(nrow = n_obs, ncol = n_cluster)
  real_par <- rep(NA, length = n_obs)
  danger_par <- rep(0, length = n_obs)
  for (k in 1:n_cluster){
    res_y[,k] <- data_y - true_score %*% t(loading_y[[k]])
  }
  for (i in 1:n_obs){
    real_par[i] <- which.min(abs(res_y[i,]))
    #if(sum(res_y[i,]^2 > (sum(noise_y^2) / n_obs))==0){
    #  danger_par[i] <- 1
    #}
  }
  
  return(list(real_cluster_mem = real_par, ucluster_distance = res_y) )
}

### data simulation with CSSCR (also include the relevance of the components)
CSSCRSim <- function(ncluster, memcluster, ncom, ndistinct, nblock, nvar, ynvar,
                     psparse = 0, pnoise_x = 0, pnoise_y = 0, clust_reg, com_rele, equal_loading = TRUE, n_test = NULL,
                     pmean_x = 0, pmean_y = 0, p_combase = 0) {
  
  # ncluster: the number of cluster
  # memcluster: number of participants in each cluster
  # ncom: number of common components
  # ndistinct: number of distinct components (a vector of length nblock, with the ith element indicating the number of distinctive components
  # in ith data block)
  # nblcok: number of blocks
  # nvar: number of variables (vector indicates the number of variables for in each data block)
  # ynvar: the number of variables in the outcome block
  # psparse: percentage of sparsity (vector indicates the percentage for each block)
  # pnoise_x: percentage of noise for predictors
  # pnoise_y: percentage of noise for the outcome
  # clust_reg: cluster-specific regression coefficients
  # com_rele: the relevance of the components (the length equals the total number of components)
  # n_test: number of tests per data block
  
  
  # irregular input
  if (length(memcluster) == 1){
    memcluster <- rep(memcluster, ncluster)
  }
  
  if (length(nvar) == 1){
    nvar <- rep(nvar, nblock)
  }
  
  if (length(ndistinct) == 1 & ndistinct != 0){
    ndistinct <- rep(ndistinct, nblock)
  }
  
  # the vector indicates the relationship between distinctive component and the number of data block
  distinct_index <- vector("numeric", length = sum(ndistinct))
  sum_var <- 0
  ini_var <- 0
  pos <- 1
  for (i in 1:nblock){
    if (sum(ndistinct) != 0){
      distinct_index[pos: pos + ndistinct[i] - 1] <- i
      pos <- pos + ndistinct[i]
    }
    ini_var <- ini_var + nvar[i]
    sum_var <- c(sum_var, ini_var)
  }
  
  # the aggregate level of information
  all_component <- sum(common, ndistinct)
  all_member <- sum(memcluster)
  all_var <- sum(nvar)
  
  # for the easy computation (fill in the 0th item)
  cluster_rep <- c(0, memcluster)
  block_rep <- c(0, nvar)
  
  # cluster assignment (becuase of the randomness, the assignment could be arbitrary, just from the first avilable
  # observation looping towards the last avilable observation)
  cluster_mem <- vector("numeric", length = all_member)
  for  (i in 1:ncluster){
    cluster_mem[(sum(cluster_rep[1:i]) + 1):sum(cluster_rep[1:i+1])] <- i
  }
  
  ## create the initial score matrix
  true_score <- list()
  for (k in 1:ncluster){
    indices <- which(cluster_mem == k)
    ori_score <- matrix(rnorm(length(indices) * all_component), nrow = length(indices), ncol = all_component)
    score_processed <- MatrixCenter(ori_score, 1, 1)
    score.de <- svd(score_processed)
    true_score[[k]] <-  score.de$u %*% t(score.de$v) * sqrt(nrow(ori_score)) #the alternative way to create the starting score matrix (that are orthogonal)
  }
  # the loading matrix for the predictors
  px <- list()
  if (equal_loading == FALSE){
    com_base <- sqrt(p_combase) * matrix(runif(all_var * all_component, min = -1, max = 1), nrow = all_var, ncol = all_component)
    for (i in 1:ncluster){
      px[[i]] <- com_base + sqrt(1 - p_combase) * matrix(runif(all_var * all_component, min = -1, max = 1), nrow = all_var, ncol = all_component)
    }
  }
  if(equal_loading == TRUE){
    px_all <- matrix(runif(all_var * all_component, min = -1, max = 1), nrow = all_var, ncol = all_component)
    for (i in 1:ncluster){
      px[[i]] <- px_all
    }
  }
  
  # generate the positions of structure-induced zeros
  distinct_zeros <- vector("numeric")
  if (sum(ndistinct) != 0){
    num_var <- 0
    for (i in 1:sum(ndistinct)){
      distinct_zeros <- c(distinct_zeros, ((all_var * (common + i - 1)) + sum_var[distinct_index[i]] + 1): ((all_var * (common + i - 1)) + sum_var[(distinct_index[i] + 1)]))
    }
  }
  # the positions that are not yet specified as zeros
  #retain_zeros <- setdiff(1: (all_var * all_component), distinct_zeros)
  
  # generate the component loading matrix for the predictors
  # the number of zeros in component loadings
  #num_zeros <- round(length(retain_zeros) * psparse)
  
  # determine the places for sparsity-imposed zeros
  #sparse_zeros <- sample(retain_zeros, num_zeros)
  for (i in 1:ncluster){
    px[[i]][distinct_zeros] <- 0
    px[[i]] <- px[[i]] * sqrt(1-pmean_x) * sqrt(1-pnoise_x)/mean(apply(px[[i]]^2,1,sum))
  }
  
  # true score for the regression problem
  #true_score_y <- true_score)
  final_x <- matrix(nrow = all_member, ncol = all_var)
  final_y <- matrix(nrow = all_member, ncol = ynvar)
  py <- list()
  
  for (k in 1:ncluster){
    py[[k]] <- matrix(nrow = ynvar, ncol = all_component)
    for(i in 1:all_component){
      py[[k]][1,i] <- clust_reg[k,i]*com_rele[i]
    }
    if(ynvar > 1){
      for (i in 2:ynvar){
        for(j in 1:all_component)
          py[[k]][i, j] <- rnorm(1,py[[k]][1, j],1)
      }
    }
  }
  
  true_score_all <- matrix(nrow = all_member, ncol =all_component)
  for (k in 1:ncluster){
    indices <- which(cluster_mem == k)
    true_score_k <- true_score[[k]]
    true_score_all[indices, ] <- true_score_k
    
    ## create the final data
    final_k <- true_score_k %*% t(px[[k]])
    final_k <- MatrixCenter(final_k,1,0)
    final_x[indices, ] <- final_k
    
    final_k <- true_score_k %*% t(py[[k]])
    final_y[indices,] <- final_k - mean(final_k)
    
  }
  
  test.index <- c()
  if(!is.null(n_test)){
    for (i in 1:ncluster){
      test.index <- c(test.index, ((i-1)*memcluster[1]+1):((i-1)*memcluster[1]+n_test))
    }
  }
  train.index <- setdiff(1:(all_member),test.index)
  final_y <- final_y * sqrt(1-pmean_y) * sqrt(1-pnoise_y)/mean(final_y^2)
  
  add_noise_x <- Add(final_x, cluster_mem, pnoise_x, pmean_x)
  add_noise_y <- Add(as.matrix(final_y), cluster_mem, pnoise_y, pmean_y)
  noise_x <- add_noise_x[[2]]
  noise_y <- add_noise_y[[2]]
  final_x <- add_noise_x[[1]]
  final_y <- add_noise_y[[1]]
  mean_y <- add_noise_y[[3]]
  final_x_test <- final_x[test.index,]
  final_x <- final_x[-test.index,]
  final_y_test <- final_y[test.index]
  final_y <- final_y[-test.index]
  
  sim = list(x = final_x, y = final_y, cluster_mem = cluster_mem[train.index], score_all = true_score_all[train.index,],
             loading_x = px, loading_y = py, noise_x = noise_x, noise_y = noise_y,
             x_test = final_x_test, y_test = final_y_test, cluster_mem_test = cluster_mem[test.index],
             mean_y = mean_y)
  return(sim)
}

### without any model selection
CSSCR <- function(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha = .8,
                  converge = 1e-7, converge_2 = 1e-7, iteration = 1000, start_part = NULL){
  
  ## fix the sparsity level to zero (p_sparse = 0)
  upper <- 1e9
  stop <- 0
  iter <- 0
  
  all_member <- nrow(data_x)
  sum_var <- ncol(data_x)
  y_var <- ncol(data_y)
  block_version_data <- list(length = 2)
  block_version_data[[1]] <- data_x[,1:n_var[1]]
  block_version_data[[2]] <- data_x[, (n_var[1] + 1):n_var[2]]
  n_total <- sum(n_com, n_distinct)
  
  ## structure-induced zeros
  distinct_index <- vector("numeric")
  distinct_zeros <- vector("numeric")
  if (sum(ndistinct) != 0){
    
    all_var <- 0
    ini_var <- 0
    for (p in 1:n_block){
      distinct_index <- c(distinct_index, rep(p, n_distinct[p]))
      ini_var <- ini_var + n_var[p]
      all_var <- c(all_var, ini_var)
    }
    
    for (r.distinct in 1:sum(n_distinct)){
      distinct_zeros <- c(distinct_zeros, ((sum_var * (n_com + r.distinct - 1)) + all_var[distinct_index[r.distinct]] + 1): ((sum_var * (n_com + r.distinct - 1)) + all_var[(distinct_index[r.distinct] + 1)]))
    }
  }
  
  # set the upper bound of minimum loss
  loss_all <- vector("numeric", length = iteration)
  
  # the starting partition
  start <- vector("numeric", length = n_cluster)
  for (y in 1:n_cluster){
    start[y] <- round(all_member / n_cluster)
  }
  start[n_cluster] <- all_member - (n_cluster - 1) * round(all_member / n_cluster)
  
  
  py <- list()
  if(is.null(start_part)){
    cluster_assign <- RandomStart(start)[[2]]
  }
  if(!is.null(start_part)){
    cluster_assign <- start_part
  }
  
  ###################################################
  #cluster_assign <- a
  svd_data <- svds(data_x, n_total)
  t <- svd_data$u
  x_square <- sum(data_x^2)
  y_square <- sum(data_y^2)
  #beta <- .5
  #alpha <- .5
  beta <- alpha * y_square / (alpha * y_square + (1-alpha) * x_square)
  
  #data_x <- MatrixCenter(data_x,1,0)
  #beta <- 0.9
  
  loss_min <- upper
  loss_p_all <- rep(NA, iteration)
  loss_t_all <- rep(NA, iteration)
  loss_t_all_1 <- rep(NA, iteration)
  loss_t_all_2 <- rep(NA, iteration)
  loss_t_all_3 <- rep(NA, iteration)
  for (v in 1:iteration){
    if(loss_min < converge & v > 20)  break
    loss_new <- rep(NA, all_member)
    if (v == 1){
      px <- t(data_x) %*% t
      px[distinct_zeros] <- 0
    }
    beta * sum((data_x - t %*% t(px))^2)
    #index.nsmallest <- sort(px^2, index.return = TRUE)$ix[1:(sparse_zeros+length(distinct_zeros))]
    #x[index.nsmallest] <- 0
    
    if (v == 1){
      for(k in 1:n_cluster){
        cluster_k <- which(cluster_assign == k)
        t_k <- t[cluster_k,]
        y_k <- data_y[cluster_k,]
        py[[k]] <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
      }
    }
    
    ############################
    
    t <- matrix(0, nrow = all_member, ncol = n_total)
    for (k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      x_k <- data_x[cluster_k,]
      xp <- beta * (x_k %*% px)
      y_k <- data_y[cluster_k,]# - mean(data_y[cluster_k])
      xp1 <- (1-beta) * (y_k %*% py[[k]])
      xp_update <- xp + xp1
      xp_svd <- svd(xp_update)
      t[cluster_k,] <- (xp_svd$u %*% t(xp_svd$v)) / sqrt(n_cluster)
    }
    ####################################
    loss_t2 <- 0
    for(k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      t_k <- t[cluster_k,]
      y_k <- data_y[cluster_k,]#-mean(data_y[cluster_k])
      loss_k <- (1-beta) * sum((y_k - t_k %*% t(py[[k]]))^2)
      loss_t2 <- loss_t2+loss_k
    }
    
    px <- t(data_x) %*% t
    px[distinct_zeros] <- 0
    
    ######################################
    loss_t <- beta * sum((data_x - t %*% t(px))^2)
    #loss_t_all_1[v] <- loss_t
    loss_t_all_2[v] <- 0
    for(k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      t_k <- t[cluster_k,]
      y_k <- data_y[cluster_k,]#-mean(data_y[cluster_k])
      reg_results <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
      py[[k]] <- reg_results
      loss_k <- (1-beta) * sum((y_k - t_k %*% t(py[[k]]))^2)
      loss_t <- loss_t+loss_k
      loss_t_all_2[v] <- loss_t_all_2[v] + loss_k
    }
    loss_t_all[v] <- loss_t
    
    if(v>1){
      loss_min <- loss_t_all[v-1] -loss_t_all[v]
    }
  }
  
  loss_final <- loss_t
  stop <- 0
  iter_all <- 0
  while(stop ==0 & iter_all < 50){
    
    iter_all <- iter_all + 1
    member_exchange <- 0
    loss_n_all <- list()
    for(n in 1:all_member){#length(cluster_assign)){
      #loss_n <- rep(NA, n_cluster)
      loss_n_all[[n]] <- rep(NA, n_cluster)
      ## get the cluster membership
      cluster_n <- cluster_assign[n]
      cluster_assign_temp <- cluster_assign
      #data_x_n <- data_x[-n,]
      #data_y_n <- data_y[-n]
      #t_n <- t[-n,]
      #cluster_assign_n <- cluster_assign[-n]
      py_temp <- list()
      px_temp <- list()
      t_temp <- list()
      
      for(g in 1:n_cluster){
        if (g == cluster_n){
          py_temp[[g]] <- py
          px_temp[[g]] <- px
          t_temp[[g]] <- t
          ##################
          loss_n_all[[n]][g] <- loss_final
        }
        if(g != cluster_n){
          cluster_assign_temp[n] <- g
          loss_min <- upper
          py_temp_k <- list()
          #loss_p_all <- rep(NA, iteration)
          loss_t_all <- rep(NA, iteration)
          
          for (v in 1:iteration){
            if(loss_min < converge_2 & v > 10)  break
            loss_new <- rep(NA, all_member)
            
            if (v == 1){
              t_temp_k <- t
              px_temp_k <- t(data_x) %*% t_temp_k
              px_temp_k[distinct_zeros] <- 0
              for(k in 1:n_cluster){
                cluster_k <- which(cluster_assign_temp == k)
                t_k <- t_temp_k[cluster_k,]
                y_k <- data_y[cluster_k,]#-mean(data_y[cluster_k])
                py_temp_k[[k]] <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
              }
            }
            
            t_temp_k <- matrix(0, nrow = all_member, ncol = n_total)
            for (k in 1:n_cluster){
              cluster_k <- which(cluster_assign_temp == k)
              x_k <- data_x[cluster_k,]
              xp <- beta * (x_k %*% px)
              y_k <- data_y[cluster_k,]# - mean(data_y[cluster_k])
              xp1 <-(1-beta) * (y_k %*% py_temp_k[[k]])
              xp_update <- xp + xp1
              xp_svd <- svd(xp_update)
              t_temp_k[cluster_k,] <- xp_svd$u %*% t(xp_svd$v) / sqrt(n_cluster)
            }
            
            px_temp_k <- t(data_x) %*% t_temp_k
            px_temp_k[distinct_zeros] <- 0
            px_temp[[k]] <- px_temp_k
            loss_t <- beta * sum((data_x - t_temp_k %*% t(px_temp_k))^2)
            for(k in 1:n_cluster){
              cluster_k <- which(cluster_assign_temp == k)
              t_k <- t_temp_k[cluster_k,]
              y_k <- data_y[cluster_k,]# - mean(data_y[cluster_k])
              reg_results <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
              py_temp_k[[k]]  <- reg_results
              loss_k <- (1-beta) * sum((y_k - t_k %*% t(py_temp_k[[k]]))^2)
              loss_t <- loss_t+loss_k
            }
            loss_t_all[v] <- loss_t
            
            if(v>1){
              loss_min <- loss_t_all[v-1] -loss_t_all[v]
            }
          }
          loss_n_all[[n]][g] <- loss_t
          py_temp[[g]] <- py_temp_k
          px_temp[[g]] <- px_temp_k
          t_temp[[g]] <- t_temp_k
        }
      }
      cluster_assign[n] <- which(loss_n_all[[n]] == min(loss_n_all[[n]]))
      g <- cluster_assign[n]
      py <- py_temp[[g]]
      px <- px_temp[[g]]
      t <- t_temp[[g]]
      loss_final <- min(loss_n_all[[n]])
      
      if(cluster_assign[n] != cluster_n){
        member_exchange <- 1
      }
    }
    
    if (member_exchange == 0){
      stop <- 1
    }
  }
  results <- list(cluster_assign = cluster_assign, loss = loss_n_all, score = t, loadings = px,
                  regs = py)
  return(results)
}

###########################################################################
###########################################################################
### without any model selection
CSSCR_nocon <- function(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha = .8,
                        converge = 1e-7, converge_2 = 1e-7, iteration = 1000, start_part = NULL){
  
  ## fix the sparsity level to zero (p_sparse = 0)
  upper <- 1e9
  stop <- 0
  iter <- 0
  
  all_member <- nrow(data_x)
  sum_var <- ncol(data_x)
  y_var <- ncol(data_y)
  block_version_data <- list(length = 2)
  block_version_data[[1]] <- data_x[,1:n_var[1]]
  block_version_data[[2]] <- data_x[, (n_var[1] + 1):n_var[2]]
  n_total <- sum(n_com, n_distinct)
  
  ## structure-induced zeros
  distinct_index <- vector("numeric")
  distinct_zeros <- vector("numeric")
  if (sum(ndistinct) != 0){
    
    all_var <- 0
    ini_var <- 0
    for (p in 1:n_block){
      distinct_index <- c(distinct_index, rep(p, n_distinct[p]))
      ini_var <- ini_var + n_var[p]
      all_var <- c(all_var, ini_var)
    }
    
    for (r.distinct in 1:sum(n_distinct)){
      distinct_zeros <- c(distinct_zeros, ((sum_var * (n_com + r.distinct - 1)) + all_var[distinct_index[r.distinct]] + 1): ((sum_var * (n_com + r.distinct - 1)) + all_var[(distinct_index[r.distinct] + 1)]))
    }
  }
  
  # set the upper bound of minimum loss
  loss_all <- vector("numeric", length = iteration)
  
  # the starting partition
  start <- vector("numeric", length = n_cluster)
  for (y in 1:n_cluster){
    start[y] <- round(all_member / n_cluster)
  }
  start[n_cluster] <- all_member - (n_cluster - 1) * round(all_member / n_cluster)
  
  
  py <- list()
  if(is.null(start_part)){
    cluster_assign <- RandomStart(start)[[2]]
  }
  if(!is.null(start_part)){
    cluster_assign <- start_part
  }
  
  ###################################################
  #cluster_assign <- a
  svd_data <- svds(data_x, n_total)
  t <- svd_data$u
  x_square <- sum(data_x^2)
  y_square <- sum(data_y^2)
  #beta <- .5
  #alpha <- .5
  beta <- alpha * y_square / (alpha * y_square + (1-alpha) * x_square)
  
  #data_x <- MatrixCenter(data_x,1,0)
  #beta <- 0.9
  
  loss_min <- upper
  loss_p_all <- rep(NA, iteration)
  loss_t_all <- rep(NA, iteration)
  loss_t_all_1 <- rep(NA, iteration)
  loss_t_all_2 <- rep(NA, iteration)
  loss_t_all_3 <- rep(NA, iteration)
  for (v in 1:iteration){
    if(loss_min < converge & v > 20)  break
    loss_new <- rep(NA, all_member)
    if (v == 1){
      px <- t(data_x) %*% t
      px[distinct_zeros] <- 0
    }
    beta * sum((data_x - t %*% t(px))^2)
    #index.nsmallest <- sort(px^2, index.return = TRUE)$ix[1:(sparse_zeros+length(distinct_zeros))]
    #x[index.nsmallest] <- 0
    
    #if(v > 1){
    #  loss_p <- beta * sum((data_x - t %*% t(px))^2)
    #  for(k in 1:n_cluster){
    #    cluster_k <- which(cluster_assign == k)
    #    t_k <- t[cluster_k,]
    #    y_k <- data_y[cluster_k]
    #    loss_k <- (1-beta) * sum((y_k-(cbind(rep(1, nrow(t_k)), t_k)%*%py[[k]]))^2)
    #    loss_p <- loss_p+loss_k
    #  }
    #  loss_p_all[v] <- loss_p
    #}
    
    if (v == 1){
      for(k in 1:n_cluster){
        cluster_k <- which(cluster_assign == k)
        t_k <- t[cluster_k,]
        y_k <- data_y[cluster_k,]
        py[[k]] <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
      }
    }
    
    ############################
    
    t <- matrix(0, nrow = all_member, ncol = n_total)
    for (k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      x_k <- data_x[cluster_k, ]
      y_k <- data_y[cluster_k]# - mean(data_y[cluster_k])
      zz <- beta * (diag(length(cluster_k)) %x% (t(px) %*% px)) + (1-beta)*(diag(length(cluster_k)) %x% (t(py[[k]]) %*% py[[k]]))
      zy <- beta * ((diag(length(cluster_k)) %x% t(px)) %*% as.vector(t(x_k))) + (1-beta)*((diag(length(cluster_k)) %x% t(py[[k]])) %*% y_k)
      t[cluster_k, ]<- matrix(inv(zz) %*% zy, nrow = length(cluster_k), byrow = TRUE)
    }
    
    ####################################
    loss_t2 <- 0
    for(k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      t_k <- t[cluster_k,]
      y_k <- data_y[cluster_k,]#-mean(data_y[cluster_k])
      loss_k <- (1-beta) * sum((y_k - t_k %*% t(py[[k]]))^2)
      loss_t2 <- loss_t2+loss_k
    }
    
    px <- t(data_x) %*% t %*% inv(t(t) %*% t)
    px[distinct_zeros] <- 0
    
    ######################################
    loss_t <- beta * sum((data_x - t %*% t(px))^2)
    #loss_t_all_1[v] <- loss_t
    loss_t_all_2[v] <- 0
    for(k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      t_k <- t[cluster_k,]
      y_k <- data_y[cluster_k,]#-mean(data_y[cluster_k])
      reg_results <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
      py[[k]] <- reg_results
      loss_k <- (1-beta) * sum((y_k - t_k %*% t(py[[k]]))^2)
      loss_t <- loss_t+loss_k
      loss_t_all_2[v] <- loss_t_all_2[v] + loss_k
    }
    loss_t_all[v] <- loss_t
    
    if(v>1){
      loss_min <- loss_t_all[v-1] -loss_t_all[v]
    }
  }
  
  loss_final <- loss_t
  stop <- 0
  iter_all <- 0
  while(stop ==0 & iter_all < 50){
    
    iter_all <- iter_all + 1
    member_exchange <- 0
    loss_n_all <- list()
    for(n in 1:all_member){#length(cluster_assign)){
      #loss_n <- rep(NA, n_cluster)
      loss_n_all[[n]] <- rep(NA, n_cluster)
      ## get the cluster membership
      cluster_n <- cluster_assign[n]
      cluster_assign_temp <- cluster_assign
      #data_x_n <- data_x[-n,]
      #data_y_n <- data_y[-n]
      #t_n <- t[-n,]
      #cluster_assign_n <- cluster_assign[-n]
      py_temp <- list()
      px_temp <- list()
      t_temp <- list()
      
      for(g in 1:n_cluster){
        if (g == cluster_n){
          py_temp[[g]] <- py
          px_temp[[g]] <- px
          t_temp[[g]] <- t
          ##################
          loss_n_all[[n]][g] <- loss_final
        }
        if(g != cluster_n){
          cluster_assign_temp[n] <- g
          loss_min <- upper
          py_temp_k <- list()
          #loss_p_all <- rep(NA, iteration)
          loss_t_all <- rep(NA, iteration)
          
          for (v in 1:iteration){
            if(loss_min < converge_2 & v > 10)  break
            loss_new <- rep(NA, all_member)
            
            if (v == 1){
              t_temp_k <- t
              px_temp_k <- t(data_x) %*% t_temp_k %*% inv(t(t_temp_k) %*% t_temp_k)
              px_temp_k[distinct_zeros] <- 0
              for(k in 1:n_cluster){
                cluster_k <- which(cluster_assign_temp == k)
                t_k <- t_temp_k[cluster_k,]
                y_k <- data_y[cluster_k,]#-mean(data_y[cluster_k])
                py_temp_k[[k]] <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
              }
            }
            
            
            #loss_p <- beta * sum((data_x - t %*% t(px_temp_k))^2)
            #for(k in 1:n_cluster){
            #  cluster_k <- which(cluster_assign_temp == k)
            #  t_k <- t[cluster_k,]
            #  y_k <- data_y[cluster_k]
            #  loss_k <- (1-beta) * sum((y_k-(cbind(rep(1, nrow(t_k)), t_k)%*%py[[k]]))^2)
            #  loss_p <- loss_p+loss_k
            #}
            #}
            t_temp_k <- matrix(0, nrow = all_member, ncol = n_total)
            for (k in 1:n_cluster){
              cluster_k <- which(cluster_assign_temp == k)
              x_k <- data_x[cluster_k,]
              xp <- beta * (x_k %*% px)
              y_k <- data_y[cluster_k,]# - mean(data_y[cluster_k])
              zz <- beta * (diag(length(cluster_k)) %x% (t(px_temp_k) %*% px_temp_k)) + (1-beta)*(diag(length(cluster_k)) %x% (t(py_temp_k[[k]]) %*% py_temp_k[[k]]))
              zy <- beta * ((diag(length(cluster_k)) %x% t(px_temp_k)) %*% as.vector(t(x_k))) + (1-beta)*((diag(length(cluster_k)) %x% t(py_temp_k[[k]])) %*% y_k)
              t_temp_k[cluster_k,] <- matrix(inv(zz) %*% zy, nrow = length(cluster_k), byrow = TRUE)
            }
            
            
            #t.ee <- eigen(t(t_new) %*% t_new, symmetric = FALSE)
            #t <- t_new %*% t.ee$vectors %*% inv(sqrt(diag(t.ee$values)))
            #gs <- gramSchmidt(t_new)
            #q <- px_temp_k %*% t(gs$R)
            #t_temp_k <- gs$Q
            
            px_temp_k <- t(data_x) %*% t_temp_k %*% inv(t(t_temp_k) %*% t_temp_k)
            px_temp_k[distinct_zeros] <- 0
            px_temp[[k]] <- px_temp_k
            loss_t <- beta * sum((data_x - t_temp_k %*% t(px_temp_k))^2)
            for(k in 1:n_cluster){
              cluster_k <- which(cluster_assign_temp == k)
              t_k <- t_temp_k[cluster_k,]
              y_k <- data_y[cluster_k,]# - mean(data_y[cluster_k])
              reg_results <- t(y_k) %*% t_k %*% inv(t(t_k) %*% t_k)
              py_temp_k[[k]]  <- reg_results
              loss_k <- (1-beta) * sum((y_k - t_k %*% t(py_temp_k[[k]]))^2)
              loss_t <- loss_t+loss_k
            }
            loss_t_all[v] <- loss_t
            
            if(v>1){
              loss_min <- loss_t_all[v-1] -loss_t_all[v]
            }
          }
          loss_n_all[[n]][g] <- loss_t
          py_temp[[g]] <- py_temp_k
          px_temp[[g]] <- px_temp_k
          t_temp[[g]] <- t_temp_k
        }
      }
      cluster_assign[n] <- which(loss_n_all[[n]] == min(loss_n_all[[n]]))
      g <- cluster_assign[n]
      py <- py_temp[[g]]
      px <- px_temp[[g]]
      t <- t_temp[[g]]
      loss_final <- min(loss_n_all[[n]])
      
      if(cluster_assign[n] != cluster_n){
        member_exchange <- 1
      }
    }
    
    if (member_exchange == 0){
      stop <- 1
    }
  }
  results <- list(cluster_assign = cluster_assign, loss = loss_n_all, score = t, loadings = px,
                  regs = py)
  return(results)
}
#########################################################################
#########################################################################
#########################################################################
MultiCSCCR <- function(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha = .8,
                       converge = 1e-8, iteration = 1000, num_starts = 1, type = NULL, con = FALSE,
                       start_part = NULL){
  
  nobs <- nrow(data_x)
  start_partition <- list()
  mem_cluster <- rep(nrow(data_x)/n_cluster, n_cluster)
  if(type == "random"){
    for(i in 1:num_starts){
      rs.results <- RandomStart(mem_cluster)
      start_partition[[i]] <- rs.results$ind
    }
  }
  if(type == "known"){
    num <- floor(nobs/10)
    for(i in 1:num_starts){
      start_partition[[i]] <- SemiRandomStart(start_part, num)
    }
  }
  for (i in 1:num_starts){
    if(i == 1){
      if(con == FALSE){
        est <- CSSCR_nocon(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster,alpha,
                           converge, converge, iteration, start_part = start_partition[[i]])
        final_loss <- est$loss
        final_results <- est
      }
      if(con == TRUE){
        est <- CSSCR_group(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha,
                           converge, converge,  iteration, start_part = start_partition[[i]])
        final_loss <- est$loss
        final_results <- est
      }
    }
    if(i != 1){
      if(con == FALSE){
        est <- CSSCR_nocon(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha,
                           converge, converge, iteration, start_part = start_partition[[i]])
        current_loss <- est$loss
        if(current_loss < final_loss){
          final_results <- est
          final_loss <- current_loss
        }
      }
      if(con == TRUE){
        est <- CSSCR_group(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha,
                           converge, converge, iteration, start_part = start_partition[[i]])
        current_loss <- est$loss
        if(current_loss < final_loss){
          final_results <- est
          final_loss <- current_loss
        }
      }
    }
  }
  final_results$loss <- final_loss
  return(final_results)
}


###################
### without any model selection
CSSCR_group <- function(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster,  alpha = .8,
                        converge = 1e-8, converge_2 = 1e-8, iteration = 1000, start_part = NULL){
  
  ## fix the sparsity level to zero (p_sparse = 0)
  upper <- 1e9
  stop <- 0
  iter <- 0
  
  all_member <- nrow(data_x)
  sum_var <- ncol(data_x)
  y_var <- ncol(data_y)
  block_version_data <- list(length = 2)
  block_version_data[[1]] <- data_x[,1:n_var[1]]
  block_version_data[[2]] <- data_x[, (n_var[1] + 1):n_var[2]]
  n_total <- sum(n_com, n_distinct)
  
  
  ## structure-induced zeros
  distinct_index <- vector("numeric")
  distinct_zeros <- vector("numeric")
  if (sum(ndistinct) != 0){
    
    all_var <- 0
    ini_var <- 0
    for (p in 1:n_block){
      distinct_index <- c(distinct_index, rep(p, n_distinct[p]))
      ini_var <- ini_var + n_var[p]
      all_var <- c(all_var, ini_var)
    }
    
    for (r.distinct in 1:sum(n_distinct)){
      distinct_zeros <- c(distinct_zeros, ((sum_var * (n_com + r.distinct - 1)) + all_var[distinct_index[r.distinct]] + 1): ((sum_var * (n_com + r.distinct - 1)) + all_var[(distinct_index[r.distinct] + 1)]))
    }
  }
  
  # set the upper bound of minimum loss
  loss_all <- vector("numeric", length = iteration)
  
  # the starting partition
  start <- vector("numeric", length = n_cluster)
  for (y in 1:n_cluster){
    start[y] <- round(all_member / n_cluster)
  }
  start[n_cluster] <- all_member - (n_cluster - 1) * round(all_member / n_cluster)
  
  
  py <- list()
  px <- list()
  
  if(is.null(start_part)){
    cluster_assign <- RandomStart(start)[[2]]
  }
  if(!is.null(start_part)){
    cluster_assign <- start_part
  }
  
  ###################################################
  #cluster_assign <- a
  data_x <- MatrixCenter(data_x,1,0)
  data_y <- data_y - mean(data_y)
  svd_data <- svd(data_x, n_total)
  t <- svd_data$u
  x_square <- sum(data_x^2)
  y_square <- sum(data_y^2)
  #beta <- .5
  #alpha <- .5
  beta <- alpha * y_square / (alpha * y_square + (1-alpha) * x_square)
  
  #data_x <- MatrixCenter(data_x,1,0)
  #beta <- 0.9
  
  loss_min <- upper
  loss_p_all <- rep(NA, iteration)
  loss_t_all <- rep(NA, iteration)
  #loss_t_all_1 <- rep(NA, iteration)
  #loss_t_all_2 <- rep(NA, iteration)
  #loss_t_all_3 <- rep(NA, iteration)
  mean_x <- matrix(nrow = n_cluster, ncol = sum_var)
  mean_y <- rep(NA, n_cluster)
  for (v in 1:iteration){
    if(loss_min < converge & v > 20)  break
    loss_new <- rep(NA, all_member)
    
    if (v == 1){
      for(k in 1:n_cluster){
        cluster_k <- which(cluster_assign == k)
        t_k <- t[cluster_k,]
        x_k <- data_x[cluster_k,]
        x_k <- MatrixCenter(x_k,1,0)
        px[[k]] <- t(x_k) %*% t_k
        px[[k]][distinct_zeros] <- 0
        y_k <- data_y[cluster_k]# - mean(data_y[cluster_k])
        t_k_comb <- cbind(rep(1,nrow(t_k)), t_k)
        py[[k]] <- t(y_k) %*% t_k_comb %*% inv(t(t_k_comb) %*% t_k_comb)
      }
    }
    
    ############################
    
    t <- matrix(0, nrow = all_member, ncol = n_total)
    for (k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      x_k <- data_x[cluster_k,]
      x_k <- MatrixCenter(x_k,1,0)
      xp <- beta * (x_k %*% px[[k]])
      y_k <- data_y[cluster_k] - py[[k]][1]# - mean(data_y[cluster_k])
      xp1 <- (1-beta) * (y_k %*% t(py[[k]][-1]))
      xp_update <- xp + xp1
      xp_svd <- svd(xp_update)
      t[cluster_k,] <- (xp_svd$u %*% t(xp_svd$v)) 
    }
    ####################################
    #px <- t(data_x) %*% t
    #px[distinct_zeros] <- 0
    
    #loss_t_all_1[v] <- loss_t
    loss_t_all[v] <- 0
    for(k in 1:n_cluster){
      cluster_k <- which(cluster_assign == k)
      t_k <- t[cluster_k,]
      x_k <- data_x[cluster_k,]
      mean_x[k,] <- apply(x_k, 2, mean)
      x_k <- MatrixCenter(x_k,1,0)
      px[[k]] <- t(x_k) %*% t_k
      px[[k]][distinct_zeros] <- 0
      y_k <- data_y[cluster_k]#-mean(data_y[cluster_k])
      #mean_y[k] <- mean(data_y[cluster_k])
      t_k_comb <- cbind(rep(1,nrow(t_k)), t_k)
      reg_results <- t(y_k) %*% t_k_comb %*% inv(t(t_k_comb) %*% t_k_comb)
      py[[k]] <- reg_results
      loss_k <- (1-beta) * sum((y_k - t_k_comb %*% t(py[[k]]))^2) + beta * sum((x_k - t_k %*% t(px[[k]]))^2)
      loss_t_all[v] <- loss_t_all[v] + loss_k
    }
    
    if(v>1){
      loss_min <- loss_t_all[v-1] -loss_t_all[v]
    }
  }
  
  loss_final <- loss_t_all[v-1]
  stop <- 0
  iter_all <- 0
  while(stop ==0 & iter_all < 50){
    
    iter_all <- iter_all + 1
    member_exchange <- 0
    loss_n_all <- list()
    for(n in 1:all_member){#length(cluster_assign)){
      #loss_n <- rep(NA, n_cluster)
      loss_n_all[[n]] <- rep(NA, n_cluster)
      ## get the cluster membership
      cluster_n <- cluster_assign[n]
      cluster_assign_temp <- cluster_assign
      #data_x_n <- data_x[-n,]
      #data_y_n <- data_y[-n]
      #t_n <- t[-n,]
      #cluster_assign_n <- cluster_assign[-n]
      py_temp <- list()
      px_temp <- list()
      t_temp <- list()
      mean_x_temp <- list()
      mean_y_temp <- list()
      
      for(g in 1:n_cluster){
        if (g == cluster_n){
          py_temp[[g]] <- py
          px_temp[[g]] <- px
          t_temp[[g]] <- t
          mean_x_temp[[g]] <- mean_x
          mean_y_temp[[g]] <- mean_y
          ##################
          loss_n_all[[n]][g] <- loss_final
        }
        if(g != cluster_n){
          cluster_assign_temp[n] <- g
          loss_min <- upper
          py_temp_k <- list()
          px_temp_k <- list()
          #loss_p_all <- rep(NA, iteration)
          loss_t_all <- rep(NA, iteration)
          mean_x_temp[[g]] <- mean_x
          mean_y_temp[[g]] <- mean_y
          
          for (v in 1:iteration){
            if(loss_min < converge_2 & v > 10)  break
            loss_new <- rep(NA, all_member)
            
            if (v == 1){
              t_temp_k <- t
              for(k in 1:n_cluster){
                cluster_k <- which(cluster_assign_temp == k)
                x_k <- data_x[cluster_k,]
                x_k <- MatrixCenter(x_k,1,0)
                t_k <- t_temp_k[cluster_k,]
                px_temp_k[[k]] <- t(x_k) %*% t_k
                px_temp_k[[k]][distinct_zeros] <- 0
                y_k <- data_y[cluster_k]#-mean(data_y[cluster_k])
                t_k_comb <- cbind(rep(1,nrow(t_k)), t_k)
                py_temp_k[[k]] <- t(y_k) %*% t_k_comb %*% inv(t(t_k_comb) %*% t_k_comb)
              }
            }
            
            t_temp_k <- matrix(0, nrow = all_member, ncol = n_total)
            for (k in 1:n_cluster){
              cluster_k <- which(cluster_assign_temp == k)
              x_k <- data_x[cluster_k,]
              
              x_k <- MatrixCenter(x_k,1,0)
              xp <- beta * (x_k %*% px_temp_k[[k]])
              y_k <- data_y[cluster_k]-py_temp_k[[k]][1]# - mean(data_y[cluster_k])
              
              xp1 <-(1-beta) * (y_k %*% t(py_temp_k[[k]][-1]))
              xp_update <- xp + xp1
              xp_svd <- svd(xp_update)
              t_temp_k[cluster_k,] <- xp_svd$u %*% t(xp_svd$v)# / sqrt(n_cluster)
            }
            
            loss_t <- 0
            for(k in 1:n_cluster){
              cluster_k <- which(cluster_assign_temp == k)
              t_k <- t_temp_k[cluster_k,]
              y_k <- data_y[cluster_k]# - mean(data_y[cluster_k])
              mean_y_temp[[g]][k] <- mean(data_y[cluster_k])
              x_k <- data_x[cluster_k,]
              mean_x_temp[[g]][k,] <- apply(x_k,2,mean)
              x_k <- MatrixCenter(x_k,1,0)
              px_temp_k[[k]] <- t(x_k) %*% t_k
              px_temp_k[[k]][distinct_zeros] <- 0
              t_k_comb <- cbind(rep(1,nrow(t_k)), t_k) 
              reg_results <- t(y_k) %*% t_k_comb %*% inv(t(t_k_comb) %*% t_k_comb)
              py_temp_k[[k]]  <- reg_results
              loss_k <- (1-beta) * sum((y_k - t_k_comb %*% t(py_temp_k[[k]]))^2) + beta * sum((x_k - t_k %*% t(px_temp_k[[k]]))^2)
              loss_t <- loss_t+loss_k
            }
            loss_t_all[v] <- loss_t
            
            if(v>1){
              loss_min <- loss_t_all[v-1] -loss_t_all[v]
            }
          }
          loss_n_all[[n]][g] <- loss_t
          py_temp[[g]] <- py_temp_k
          px_temp[[g]] <- px_temp_k
          t_temp[[g]] <- t_temp_k
        }
      }
      cluster_assign[n] <- which(loss_n_all[[n]] == min(loss_n_all[[n]]))
      g <- cluster_assign[n]
      py <- py_temp[[g]]
      px <- px_temp[[g]]
      t <- t_temp[[g]]
      mean_x <- mean_x_temp[[g]] 
      mean_y <- mean_y_temp[[g]]
      loss_final <- min(loss_n_all[[n]])
      
      if(cluster_assign[n] != cluster_n){
        member_exchange <- 1
      }
    }
    
    if (member_exchange == 0){
      stop <- 1
    }
  }
  results <- list(cluster_assign = cluster_assign, loss = loss_final, score = t, loadings = px,
                  regs = py, loss_all = loss_n_all, loss_min = loss_min, mean_x = mean_x, mean_y = mean_y)
  return(results)
}

CSSCRPredict <- function(old_data_x=NULL, new_data_x=NULL, old_loading_x, old_loading_y, mean_x, new_assign = NULL){
  
  n_new <- nrow(new_data_x)
  n_cluster <- length(old_loading_x)
  n_var <- nrow(old_loading_x[[1]])
  
  if(is.null(new_assign)){
    loss_x <- matrix(nrow = n_new, ncol = n_cluster)
    for (i in 1:n_new){
      for(j in 1:n_cluster){
        score_i <- t(new_data_x[i,]- mean_x[j,]) %*% old_loading_x[[j]] %*% inv(t(old_loading_x[[j]]) %*% old_loading_x[[j]])
        loss_x[i,j] <- sum((new_data_x[i,] - mean_x[j,]- score_i %*% t(old_loading_x[[j]]))^2)
      }
    }
    new_assign <- apply(loss_x,1,function(x) which.min(x))
  }
  predict_y <- rep(NA,n_new) 
  for(i in 1:n_new){
    new_cluster <- new_assign[i]
    loading_i <- old_loading_y[[new_cluster]]
    score_i <- t(new_data_x[i,]- mean_x[new_cluster,]) %*% old_loading_x[[new_cluster]] %*% inv(t(old_loading_x[[new_cluster]]) %*% old_loading_x[[new_cluster]])
    score_i_new <- cbind(rep(1,nrow(score_i)), score_i)
    predict_y[i] <- score_i_new %*% t(loading_i)
  }
  
  results <- list(predict_y = predict_y, predict_cluster = new_assign)
  return(results)
}

#######################################
###################
### without any model selection
CSCCR_single <- function(data_x_complete,data_y_complete,n_block, n_com, n_distinct, n_var, alpha = .8,
                         converge = 1e-8, converge_2 = 1e-8, iteration = 1000, cluster_assign){
  
  ## fix the sparsity level to zero (p_sparse = 0)
  upper <- 1e9
  stop <- 0
  iter <- 0
  
  all_member <- nrow(data_x)
  sum_var <- ncol(data_x)
  y_var <- ncol(data_y)
  block_version_data <- list(length = 2)
  block_version_data[[1]] <- data_x[,1:n_var[1]]
  block_version_data[[2]] <- data_x[, (n_var[1] + 1):n_var[2]]
  n_total <- sum(n_com, n_distinct)
  
  
  ## structure-induced zeros
  distinct_index <- vector("numeric")
  distinct_zeros <- vector("numeric")
  if (sum(ndistinct) != 0){
    
    all_var <- 0
    ini_var <- 0
    for (p in 1:n_block){
      distinct_index <- c(distinct_index, rep(p, n_distinct[p]))
      ini_var <- ini_var + n_var[p]
      all_var <- c(all_var, ini_var)
    }
    
    for (r.distinct in 1:sum(n_distinct)){
      distinct_zeros <- c(distinct_zeros, ((sum_var * (n_com + r.distinct - 1)) + all_var[distinct_index[r.distinct]] + 1): ((sum_var * (n_com + r.distinct - 1)) + all_var[(distinct_index[r.distinct] + 1)]))
    }
  }
  
  # set the upper bound of minimum loss
  loss_all <- vector("numeric", length = iteration)
  ###################################################
  px <- list()
  py <- list()
  t <- matrix(nrow = all_member, ncol = n_total)
  #cluster_assign <- a
  n_cluster <- length(unique(cluster_assign))
  mean_x <- matrix(nrow = n_cluster, ncol = sum_var)
  for (i in 1:n_cluster){
    data_x <- data_x_complete[which(cluster_assign == i),]
    mean_x[i,] <- apply(data_x,2,mean)
    data_x <- MatrixCenter(data_x,1,0)
    
    data_y <- data_y_complete[which(cluster_assign == i)]
    data_y_center <- data_y - mean(data_y)
    svd_data <- svd(data_x, n_total)
    t_i <- svd_data$u
    x_square <- sum(data_x^2)
    y_square <- sum(data_y_center^2)
    #beta <- .5
    #alpha <- .5
    beta <- alpha * y_square / (alpha * y_square + (1-alpha) * x_square)
    
    #data_x <- MatrixCenter(data_x,1,0)
    #beta <- 0.9
    
    loss_min <- upper
    loss_t_all <- rep(NA, iteration)
    
    for (v in 1:iteration){
      if(loss_min < converge & v > 20)  break
      loss_new <- rep(NA, all_member)
      
      if (v == 1){
        
        px_i <- t(data_x) %*% t_i
        px_i[distinct_zeros] <- 0
        t_comb <- cbind(rep(1,nrow(t_i)), t_i)
        py_i <- t(data_y) %*% t_comb %*% inv(t(t_comb) %*% t_comb)
      }
      
      ############################
      
      xp <- beta * (data_x %*% px_i)
      y_k <- data_y - py_i[1]# - mean(data_y[cluster_k])
      xp1 <- (1-beta) * (y_k %*% t(py_i[-1]))
      xp_update <- xp + xp1
      xp_svd <- svd(xp_update)
      t_i <- (xp_svd$u %*% t(xp_svd$v)) 
      ####################################
      #px <- t(data_x) %*% t
      #px[distinct_zeros] <- 0
      
      #loss_t_all_1[v] <- loss_t
      loss_t_all[v] <- 0
      
      px_i <- t(data_x) %*% t_i
      px_i[distinct_zeros] <- 0
      t_comb <- cbind(rep(1,nrow(t_i)), t_i)
      py_i <- t(data_y) %*% t_comb %*% inv(t(t_comb) %*% t_comb)
      loss_k <- (1-beta) * sum((data_y - t_comb %*% t(py_i))^2) + beta * sum((data_x - t_i %*% t(px_i))^2)
      loss_t_all[v] <- loss_t_all[v] + loss_k
      
      if(v>1){
        loss_min <- loss_t_all[v-1] -loss_t_all[v]
      }
    }
    
    t[which(cluster_assign == i),] <- t_i
    px[[i]] <- px_i
    py[[i]] <- py_i
  }
  
  
  results <- list(loss = loss_min, score = t, loadings = px,
                  regs = py, mean_x = mean_x)
  return(results)
}

########## small scale simulations
pnoisey <- .1
ncluster <- 2
memcluster <- 40
common <- 2
ndistinct <- c(1,1)
nblock <- 2
nvar <- c(10,10)
psparse <- 0
ntest <- 5
clust_reg <- matrix(c(-sqrt(.6), sqrt(.6), sqrt(.3), -sqrt(.3), -sqrt(.5), sqrt(.5), -sqrt(.4), sqrt(.4)),  nrow = 2, ncol = 4)
com_rele <- matrix(c(1,1,1,1,1,.05,1,1,1,1,.05,1), nrow = 3, ncol = 4, byrow = TRUE)
ynvar <- 1
## code for small-scale simulations
rep <- 1:10
conditions <- expand.grid(pnoise_x = c(.1,.3), 
                          pmean_x = c(.1,.9), pmean_y = c(.1,.9),
                          p_combase = c(0,.8,.95), alpha_all = c(.95,.5),
                          rele = c(1,2,3), rep = rep)
no_cores <- 30
## open the connection and register the cores
set.seed(921009)
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
foreach(i = 1:nrow(conditions),
        .packages = c("mbclusterwise", "flexmix", "combinat", "mclust",
                      "iCluster", "ClusterSSCA", "PCovR"), .combine=rbind) %dopar%{

  compute_results <- rep(NA, 15)

  pnoisex <- conditions$pnoise_x[i]
  pmeanx <- conditions$pmean_x[i]
  pmeany <- conditions$pmean_y[i]
  pcombase <- conditions$p_combase[i]
  alpha <- conditions$alpha_all[i]
  rele <- conditions$rele[i]
  rep <- conditions$rep[i]
  com_rele_i <- com_rele[rele,]
  
  sim.data <- CSSCRSim(ncluster, memcluster, common, ndistinct, nblock, nvar, ynvar,
                       psparse = 0, pnoise_x = pnoisex, pnoise_y = pnoisey,clust_reg, com_rele_i, equal_loading = FALSE, n_test = ntest,
                       pmean_x = pmeanx, pmean_y = pmeany, p_combase = pcombase)
  data_x <- sim.data$x
  data_y <- sim.data$y
  true_score <- sim.data$score_all
  loading_x <- sim.data$loading_x
  loading_y <- sim.data$loading_y
  true_cluster_mem <- sim.data$cluster_mem
  noise_x <- sim.data$noise_x
  noise_y <- sim.data$noise_y
  data_x_test <- sim.data$x_test
  data_y_test <- sim.data$y_test
  true_y_mean <- sim.data$mean_y
  cluster_mem_test <- sim.data$cluster_mem_test
  ############################################################
  n_block <- nblock
  n_com <- common
  n_distinct <- ndistinct
  n_var <- nvar
  n_cluster <- ncluster
  start_part <- c(rep(1,35), rep(2,35))
  ####
  # Method 1
  results2 <- MultiCSCCR(data_x,data_y,n_block, n_com, n_distinct, n_var, n_cluster, alpha = alpha,
                         converge = 1e-6, iteration = 100, num_starts = 5, type = "known", con = TRUE,
                         start_part = as.vector(results4$cluster_mem))
  emp.score <- results2$score
  #condition.results[i,1] <- adjustedRandIndex(results2$cluster_assign, true_cluster_mem)
  compute_results[1] <- adjustedRandIndex(results2$cluster_assign, true_cluster_mem)
  loading_x_csccr <- results2$loadings
  loading_y_csccr <- results2$regs
  mean_x <- results2$mean_x
  mean_y <- results2$mean_y
  predict_y <- CSSCRPredict(data_x, data_x_test, loading_x_csccr, loading_y_csccr, mean_x)
  csccr_residual <- data_y_test - predict_y[[1]]
  #condition.results[i,3] <- mean(csccr_residual^2)
  compute_results[3] <- mean(csccr_residual^2)
  new_mem <- predict_y[[2]]
  #condition.results[i,2] <- adjustedRandIndex(new_mem,cluster_mem_test)
  compute_results[2] <- adjustedRandIndex(new_mem,cluster_mem_test)
  ####
  # Method 2: the two-step approach with iCluster
  iclust.results <- iCluster2(list(data_x[,1:10], data_x[,11:20]), n_cluster)
  #iclust.results$clusters
  #condition.results[i,4] <- adjustedRandIndex(iclust.results$clusters, true_cluster_mem)
  compute_results[4]<- adjustedRandIndex(iclust.results$clusters, true_cluster_mem)
  new_mem <- rep(NA, nrow(data_x_test))
  for(j in 1:nrow(data_x_test)){
    new_data <- rbind(data_x, data_x_test[j,])
    new.iclust.results <- iCluster2(list(new_data[,1:10], new_data[,11:20]), n_cluster)
    new_mem[j] <- new.iclust.results$clusters[(nrow(data_x)+1)]
  }
  #condition.results[i,5] <- adjustedRandIndex(new_mem,cluster_mem_test)
  compute_results[5] <- adjustedRandIndex(new_mem,cluster_mem_test)
  results3 <- CSCCR_single(data_x,data_y,n_block, n_com, n_distinct, n_var, alpha = alpha,
                           converge = 1e-6, converge_2 = 1e-6, iteration = 100,
                           iclust.results$clusters)
  loading_x_csccr <- results3$loadings
  loading_y_csccr <- results3$regs
  mean_x <- results3$mean_x
  predict_y <- CSSCRPredict(data_x, data_x_test, loading_x_csccr, loading_y_csccr, mean_x, new_assign = new_mem)
  iclust_residual <- data_y_test - predict_y[[1]]
  #condition.results[i,6] <- mean(iclust_residual^2)
  compute_results[6] <- mean(iclust_residual^2)
  ###
  # Method3: the two-step approach with CSSCA
  results4 <- FixedCSSCA(data_x,n_block, n_com, n_distinct, n_var, n_cluster, 0)
  loading_x_cssca <- results4$loadings
  loading_y_cssca <- list()
  mean_x <- matrix(nrow = n_cluster, ncol=sum(n_var))
  for (j in 1:n_cluster){
    y_j <- data_y[results4$cluster_mem == j]
    score_j <- results4$scores[[j]]
    cssca_lm <- lm(y_j ~ score_j)
    loading_y_cssca[[j]] <- t(cssca_lm$coefficients)
    mean_x[j,] <- apply(data_x[results4$cluster_mem == j,], 2, mean)
  }
  #condition.results[i,7] <- adjustedRandIndex(as.vector(results4$cluster_mem), true_cluster_mem)
  compute_results[7] <- adjustedRandIndex(as.vector(results4$cluster_mem), true_cluster_mem)
  predict_y <- CSSCRPredict(data_x, data_x_test, loading_x_cssca, loading_y_cssca, mean_x)
  cssca_residual <- data_y_test - predict_y[[1]]
  #condition.results[i,9] <- mean(cssca_residual^2)
  compute_results[9] <- mean(cssca_residual^2)
  new_mem <- predict_y[[2]]
  #condition.results[i,8] <- adjustedRandIndex(new_mem,cluster_mem_test)
  compute_results[8] <- adjustedRandIndex(new_mem,cluster_mem_test)
  ###
  ## Method 4: Cluster-wise regression
  all_data <- as.data.frame(cbind(data_x,data_y))
  colnames(all_data) <- c("a","b","c","d","e","f","g","h","i",
                          "j","k","l","m","n","o","p","q","r",
                          "s","t","y")
  new_data <- as.data.frame(data_x_test)
  colnames(new_data) <- c("a","b","c","d","e","f","g","h","i",
                          "j","k","l","m","n","o","p","q","r",
                          "s","t")
  clr_results <- flexmix(y~a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t,data = all_data, k =2)
  #condition.results[i,10] <- adjustedRandIndex(clusters(clr_results), true_cluster_mem)
  compute_results[10] <- adjustedRandIndex(clusters(clr_results), true_cluster_mem)
  clr_residual <- data_y_test - predict(clr_results, newdata = new_data, aggregate=TRUE)[[1]]
  new_data_fake <- cbind(new_data, rep(1,nrow(new_data)))
  names(new_data_fake)[(sum(n_var)+1)] <- "y"
  new_mem <- clusters(clr_results, newdata = new_data_fake)
  #condition.results[i,11] <- adjustedRandIndex(new_mem,cluster_mem_test)
  compute_results[11] <- adjustedRandIndex(new_mem,cluster_mem_test)
  #condition.results[i,12] <- mean(clr_residual^2)
  compute_results[12] <- mean(clr_residual^2)
  ###
  ## Method 5: multiblock regression
  data_y_matrix <- as.matrix(data_y)
  rownames(data_y_matrix) <- 1:length(data_y)
  rownames(data_x) <- 1:length(data_y)
  cluster_pls <- cw.multiblock(Y = data_y_matrix, X = data_x, blo = n_var, option = "none", G = n_cluster, H = 4)
  #condition.results[i,13] <- adjustedRandIndex(cluster_pls$cluster, true_cluster_mem)
  compute_results[13] <- adjustedRandIndex(cluster_pls$cluster, true_cluster_mem)
  predict_pls <- cw.predict(data_x_test, cluster_pls)
  predict_y_pls <- rep(NA, length(data_y_test))
  for(j in 1:length(data_y_test)){
    cluster.i <- as.numeric(predict_pls$clusternew)[j]
    index <- sum(as.numeric(predict_pls$clusternew)[1:j]==cluster.i)
    predict_y_pls[j] <- predict_pls$Ypred.raw[[cluster.i]][index]
  }
  new_mem <- predict_pls$clusternew
  #condition.results[i,14] <- adjustedRandIndex(new_mem,cluster_mem_test)
  compute_results[14]<- adjustedRandIndex(new_mem,cluster_mem_test)
  pls_residual <- data_y_test - predict_y_pls
  #condition.results[i,15] <- mean(pls_residual^2)
  compute_results[15]<-mean(pls_residual^2)
  
  save(compute_results, file = paste0(i,".RData"))
                      }

setwd("C:/Users/Shuai Yuan/surfdrive/CSCR/results")
conditions.results <- conditions
conditions.results <- cbind(conditions.results, matrix(nrow = nrow(conditions), ncol = 15))
for(i in 1:nrow(conditions)){
  load(paste0(i, ".RData"))
  conditions.results[i,8:22] <- compute_results
}
colnames(conditions.results)[c(10,13,16,19,22)] <- c("CSCR_accu", "iCluster_accu", "CSSCA_accu",
                                                  "CR_accu", "PLS_accu")
colnames(conditions.results)[c(8,11,14)] <- c("CSCR_ari", "iCluster_ari",
                                              "CSSCA_ari") 
setwd("C:/Users/Shuai Yuan/surfdrive/CSCR/addition")
for(i in 1:nrow(conditions)){
  load(paste0(i, ".RData"))
  conditions.results[i,22] <- pls_results
}
setwd("C:/Users/Shuai Yuan/surfdrive/CSCR/addition1")
for(i in 1:nrow(conditions)){
  load(paste0(i, ".RData"))
  conditions.results[i,12:13] <- icluster_results
}
a <- conditions.results %>%
  filter(p_combase == .95) %>%
  group_by(pmean_x, rele, alpha_all) %>%
  dplyr::summarise(cscr = mean(CSCR_accu), icluster = mean(iCluster_accu), 
            cssca = mean(CSSCA_accu), cr = mean(CR_accu), pls = mean(PLS_accu))

setwd("C:/Users/Shuai Yuan/surfdrive/CSCR/reports")  
a <- conditions.results %>%
  filter(alpha_all == .95 ) %>%
  group_by(pmean_x, rele, p_combase, pmean_y) %>%
  dplyr::summarise(cscr = mean(CSCR_accu), cscr_ari = mean(CSCR_ari), 
                   icluster = mean(iCluster_accu), icluster_ari = mean(iCluster_ari), 
                   cssca = mean(CSSCA_accu), cssca_ari = mean(CSSCA_ari), cr = mean(CR_accu), pls = mean(PLS_accu))

a <- conditions.results %>%
  group_by(alpha_all, pmean_x) %>%
  dplyr::summarise(cscr = mean(CSCR_accu), cscr_ari = mean(CSCR_ari))

a <- conditions.results %>%
  filter(alpha_all == .95 & pmean_x == .1) %>%
  group_by(p_combase) %>%
  summarise_all(mean)
write.csv(a, file = "pcombase.csv")

a <- conditions.results %>%
  filter(alpha_all == .95 & pmean_x == .1) %>%
  group_by(rele) %>%
  summarise_all(mean)
write.csv(a, file = "rele.csv")

write.csv(condition.results, file = "results.csv")
