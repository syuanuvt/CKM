#### examine the novel variable selection methods in k-means
library(sparcl)
library(rARPACK)
library(combinat)
library(mclust)
library(dplyr)
library(bookdown)
#library("BiocManager")
#BiocManager::install("Biobase")
library(Biobase)
library("doParallel")
library(snow)
library(mclust)
library(clustrd)
library(cluster)
library(remotes)
#install.packages("RSpectra")
library(GGally)
library(CKM)
library(fpc)
library(NbClust)
library(multichull)

##################################################################################
### the hill climbing methdos (not developed by us)
withinss = function(X,G,K){
  if(is.vector(X) && is.atomic(X)){
    group = list()
    wcss = 0
    for(j in 1:K){
      group[[j]] = which(G == j)
      l = length(group[[j]])
      if(l>1){
        wcss = wcss + var(X[group[[j]]])*(l-1)
      }
    }
  } else if (is.matrix(X)){
    group = list()
    wcss = 0
    for(j in 1:K){
      group[[j]] = which(G == j)
      l = length(group[[j]])
      if(l>1){
        wcss = wcss + sum(apply(X[group[[j]],],2,var)*(l-1))
      }
    }
  } else {
    cat("X is niether a vector nor a matrix! \n")
    return(NULL)
  }

  return(wcss)
}

Alternate= function(X, k,tot, initial_set, s, itermax, threshold){
  p = dim(X)[2]
  set0 = initial_set
  set1 = c(0)
  iternum = 0
  while(iternum<= itermax && length(setdiff(set1,set0)) + length(setdiff(set0,set1)) > threshold ){
    clustering = kmeans(X[,set0],iter.max = 20, centers=k,algorithm = "Hartigan-Wong",trace = 0,nstart=20)
    result = clustering$cluster

    wcss = apply(X,2,withinss,G = result, K = k)
    iternum = iternum + 1

    set1 = set0
    set0 = which(rank((tot-wcss)/tot,ties.method = "random") > p-s)
  }
  out = list(final_set = set0, iternum = iternum, result = result, betweenss = clustering$betweenss)
  return(out)
}

#compute within-cluster distance by clustering feature by feature, select S of size s based on this
hill_climb_GSS = function(X,k,nperms=20,itermax,threshold,tolerance){
  X = scale(X)
  n = dim(X)[1]
  p = dim(X)[2]
  tot = apply(X,2,var)*(n-1)
  permx <- list()
  for(i in 1:nperms){
    permx[[i]] <- matrix(NA, nrow=n, ncol=p)
    for(j in 1:p) permx[[i]][,j] <- sample(X[,j])
  }
  wcss = rep(0,p)
  for(j in 1:p){
    clustering = kmeans(X[,j],iter.max = 10, centers = k,algorithm = "Hartigan-Wong", trace = 0, nstart = 5)
    wcss[j] = clustering$tot.withinss
  }
  rank0 = rank((tot-wcss)/tot,ties.method = "random")
  golden.ratio = 2/(sqrt(5) +1)
  iteration = 0
  upper.bound = p
  lower.bound = 1
  p1 = floor(upper.bound - golden.ratio*(upper.bound-lower.bound))
  p2 = floor(lower.bound + golden.ratio*(upper.bound-lower.bound))
  #evaluate the gap statistics using p1 and p2
  initial_set = which(rank0 > p-p1)
  out1 = Alternate(X, k,tot, initial_set, p1, itermax, threshold)
  permtots = rep(0,nperms)
  for(t in 1:nperms){
    permresult = kmeans(permx[[t]][,out1$final_set], iter.max = 50, centers=k, algorithm = "Hartigan-Wong", trace = 0, nstart = 5)
    permtots[t] <- permresult$betweenss
  }
  gap1 = log(out1$betweenss) - mean(log(permtots))
  initial_set = which(rank0 > p-p2)
  out2 = Alternate(X, k,tot, initial_set, p2, itermax, threshold)
  permtots = rep(0,nperms)
  for(t in 1:nperms){
    permresult = kmeans(permx[[t]][,out2$final_set], iter.max = 100, centers=k, algorithm = "Hartigan-Wong", trace = 0, nstart = 5)
    permtots[t] <- permresult$betweenss
  }
  gap2 = log(out2$betweenss) - mean(log(permtots))

  while(abs(upper.bound - lower.bound) > tolerance)
  {
    iteration = iteration + 1
    if(gap2 < gap1) # then the maximum is to the left of x2
    {
      upper.bound = p2
      p2 = p1
      gap2 = gap1
      p1 = floor(upper.bound - golden.ratio*(upper.bound - lower.bound))
      #evaluate gaps for p1
      initial_set = which(rank0 > p-p1)
      out1 = Alternate(X, k,tot, initial_set, p1, itermax, threshold)

      permtots = rep(0,nperms)
      for(t in 1:nperms){
        permresult = kmeans(permx[[t]][,out1$final_set], iter.max = 20, centers=k, algorithm = "Hartigan-Wong", trace = 0)
        permtots[t] <- permresult$betweenss
      }
      gap1 = log(out1$betweenss) - mean(log(permtots))
    } else {
      # the minimum is to the right of x1
      lower.bound = p1
      p1 = p2
      gap1 = gap2
      p2 = floor(lower.bound + golden.ratio * (upper.bound - lower.bound))
      #evaluate gaps for p2
      initial_set = which(rank0 > p-p2)
      out2 = Alternate(X, k,tot, initial_set, p2, itermax, threshold)

      permtots = rep(0,nperms)
      for(t in 1:nperms){
        permresult = kmeans(permx[[t]][,out2$final_set], iter.max = 20, centers=k, algorithm = "Hartigan-Wong", trace = 0)
        permtots[t] <- permresult$betweenss
      }
      gap2 = log(out2$betweenss) - mean(log(permtots))
    }
  }
  s = floor((lower.bound + upper.bound)/2)
  initial_set = which(rank0 > s)
  out = Alternate(X, k,tot, initial_set, s, 2*itermax, threshold)
  output = list(final_set = out$final_set, iternum = iteration, result = out$result, s = s, gap = max(gap1, gap2))
  return(output)
}

## the function to find the local maxima
localMaxima <- function(x) {
  # Use -Inf instead if x is numeric (non-integer)
  y <- diff(c(-.Machine$integer.max, x)) > 0L
  rle(y)$lengths
  y <- cumsum(rle(y)$lengths)
  y <- y[seq.int(1L, length(y), 2L)]
  if (x[[1]] == x[[2]]) {
    y <- y[-1]
  }
  y
}

###########################################################################################################
##############Simulation 1: test CKM itself and the other two methods #####################################
###########################################################################################################
set.seed(970912)
n.cluster <- 3
n.obs <- c(75, 225)
n.noisevar <- c(5, 25, 50, 100, 500, 1000)
var <- 1
n.validvar <- c(25,50,100)
nmu <- c(0.6,0.7,0.8,1)

con.rep <- 1:50
condition0 <- expand.grid(nobs = n.obs, nnoisevar= n.noisevar, nvalidvar = n.validvar,
                          nmu = nmu, rep = con.rep)


#setwd("M:/JCDR sim/sim0.new")
#setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim0.new")
# run the script with multi-core systems
setwd("//tsclient/C/Users/Shuai Yuan/Documents/CKM_new/CKM_revision/sim1")
no_cores <- 30
#no_cores <- 2
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
## from iteration 1576, we start recording the time
# to store the final results (including congruence between the simulation loading matrics, ARI of iCluster(which could already been obtained here),
# ARI of iCluster, and the congruence between obtained loading matrics and simulatd loading matrices)
sim0_data <- foreach(h = 1:nrow(condition0),
                     .packages = c("mclust", "combinat",
                                   "rARPACK", "Biobase", "CKM", "RSpectra", "cluster"
                     ), .combine=rbind) %dopar%{

                       #time.start <- proc.time()
                       #if(!file.exists(paste0(h, ".RData"))){

                       n.obs <- condition0$nobs[h]
                       n.noisevar <- condition0$nnoisevar[h]
                       n.validvar <- condition0$nvalidvar[h]
                       mu <- condition0$nmu[h]

                       n.totalvar <- n.noisevar + n.validvar

                       sim.data <- DataGenCKM(n.obs, n.cluster, n.validvar, n.noisevar, mu, var)
                       dataset <- sim.data$data
                       cluster.assign <- sim.data$cluster.assign

                       ##############################################
                       prc1 <- proc.time()
                       results <- CKMSelNo(dataset, n.cluster, n.noisevar)
                       use.time <- proc.time() - prc1

                       records <- classError(cluster.assign, results$cluster.assign)[[2]]

                       out <- list(value = records, time = use.time[1])

                       save(out, file = paste0(h, ".RData"))
                     }
#}

stopCluster(c1)
###################################################

######################################################################################
##############Simulation 2: Comparison with others methods############################
######################################################################################
set.seed(970912)
n.cluster <- c(3,5,30)
n.noisevar <- c(5,50,250,1000)
var <- 1
n.rep <- 20
n.validvar <- 50
nmu <- c(0.6,0.7,0.8,1)
con.rep <- 1:40
#condition1 <- expand.grid(nobs = n.obs, nnoisevar= n.noisevar, nmu = nmu, rep = con.rep)
condition1 <- expand.grid(ncluster = n.cluster, nnoisevar= n.noisevar, nvalidvar = n.validvar,
                          nmu = nmu, rep = con.rep)
setwd("E:/Users/u1275970/Documents/CKM/sim2_4")
#setwd("//tsclient/C/Users/Shuai Yuan/Documents/CKM_new/CKM_revision/sim1")
#setwd("C:/Users/Shuai Yuan/Documents/CKM_1/data analysis/sim2_add")
#setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim1.new")

# run the script with multi-core systems
no_cores <- 30
#no_cores <- 2
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
## from iteration 1576, we start recording the time
# to store the final results (including congruence between the simulation loading matrics, ARI of iCluster(which could already been obtained here),
# ARI of iCluster, and the congruence between obtained loading matrics and simulatd loading matrices)
sim1_data <- foreach(h = 1:nrow(condition1),
                             .packages = c("mclust", "combinat",
                                           "sparcl",   "rARPACK", "Biobase", "CKM", "RSpectra", "cluster"
                             ), .combine=rbind) %dopar%{

                               #time.start <- proc.time()
                               #if(!file.exists(paste0(h, ".RData"))){
                               #n.obs <- condition1$nobs[h]
                               n.cluster <- condition1$ncluster[h]
                               n.obs <- n.cluster * 50
                               n.noisevar <- condition1$nnoisevar[h]
                               mu <- condition1$nmu[h]
                               n.totalvar <- n.noisevar + n.validvar
                               records <- matrix(nrow = 3, ncol = 4)

                               sim.data <- DataGenCKM(n.obs, n.cluster, n.validvar, n.noisevar, mu, var)
                               dataset <- sim.data[[1]]
                               cluster.assign <- sim.data[[2]]
                               valid.set <- 1:n.validvar
                               ##############################################
                               valid.set.test <- list()
                               ##############################################
                               #prc1 <- proc.time()
                               #results <- try(CKMSelVar(dataset, n.cluster))
                               #a <- proc.time() - prc1
                               #if(inherits(results, "try-error"))
                               #{
                                # records[3,1] <- NA
                                # records[2,1] <- NA
                                # records[1,1] <- NA
                                # valid.set.test[[1]] <- NA
                               #}
                               #if(!inherits(results, "try-error"))
                               #{
                                #records[3,1] <- a[1]
                                #records[2,1] <- length(results$signaling.set)
                                #records[1,1] <- classError(cluster.assign, results$cluster.assign)[[2]]
                                #valid.set.test[[1]] <- results$signaling.set
                               #}

                               #prc2 <- proc.time()
                               #results.gss <- hill_climb_GSS(dataset, n.cluster, nperms=n.rep,itermax=20,threshold=0,tolerance=1)
                               #a <- proc.time() - prc2
                               #records[3,2] <- a[1]
                               #records[2,2] <- length(results.gss$final_set)
                               #records[1,2] <- classError(cluster.assign, results.gss$result)[[2]]
                               #valid.set.test[[2]] <- results.gss$final_set

                               ################################################
                               if(n.cluster != 30){
                                prc3 <- proc.time()
                                permute.method <- try(KMeansSparseCluster.permute(dataset, K = n.cluster, wbounds = seq(1.001,10,len= 100), nperms=n.rep))
                                a <- proc.time() - prc3
                                if(inherits(permute.method, "try-error"))
                                { 
                                  prc3 <- proc.time()
                                  permute.method <- try(KMeansSparseCluster.permute(dataset, K = n.cluster, wbounds = seq(1.001,10,len= 100), nperms=n.rep))
                                  a <- proc.time() - prc3
                                  if(inherits(permute.method, "try-error")){
                                    prc3 <- proc.time()
                                    permute.method <- try(KMeansSparseCluster.permute(dataset, K = n.cluster, wbounds = seq(1.001,10,len= 100), nperms=n.rep))
                                    a <- proc.time() - prc3
                                    if(inherits(permute.method, "try-error")){
                                      records[3,3] <- NA
                                      records[2,3] <- NA
                                      records[1,3] <- NA
                                      valid.set.test[[3]] <- NA
                                    }
                                  }
                                  
                                 }
                                if(!inherits(permute.method, "try-error"))
                                {
                                  max.gap <- max(permute.method$gaps)
                                  max.gap.sd <- permute.method$sdgaps[which(permute.method$gaps == max.gap)[1]]
                                  gap.crit <- max.gap - max.gap.sd
                                  wbound.opt <- permute.method$wbounds[sort(which(permute.method$gaps < gap.crit), decreasing = TRUE)[1]]
                                  result.method1 <- KMeansSparseCluster(dataset, K = n.cluster, wbounds = wbound.opt, nstart = 1000)
                                  records[2,3] <- length(which(result.method1[[1]]$ws != 0))
                                  records[1,3] <- classError(cluster.assign, result.method1[[1]]$Cs)[[2]]
                                  records[3,3] <- a[1]
                                  valid.set.test[[3]] <- which(result.method1[[1]]$ws != 0)
                                }
                               }
                               ############################################
                               #prc4 <- proc.time()
                               #kmeans.results <- kmeans(dataset, n.cluster, nstart = n.rep)
                               #a <- proc.time() - prc4
                               #records[3,4] <- a[1]
                               #records[2,4] <- ncol(dataset)
                               #records[1,4] <- classError(cluster.assign, kmeans.results$cluster)[[2]]
                               #valid.set.test[[4]] <- 1:ncol(dataset)
                               ###########################################
                               #prc5 <- proc.time()
                               #results.rkm <- cluspca(dataset, n.cluster, n.cluster, alpha = NULL, method = "RKM")
                               #a <- proc.time() - prc5
                               #records[3,5] <- a[1]
                               #records[2,5] <- ncol(dataset)
                               #records[1,5] <- classError(cluster.assign, results.rkm$cluster)[[2]]
                               #valid.set.test[[5]] <- 1:ncol(dataset)

                               results <- list(records = records, valid.set.test = valid.set.test, dataset = dataset)

                               save(results, file = paste0(h, ".RData"))
                             }

stopCluster(c1)
###################################################
# to check which files exist
setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim1.new")
null.sim1 <- c()
for (i in 1:2400){
  if(!file.exists(paste0(i, ".RData"))){
    null.sim1 <- c(null.sim1, i)
  }
}
setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim2.new")
null.sim2 <- c()
for (i in 1:1200){
  if(!file.exists(paste0(i, ".RData"))){
    null.sim2 <- c(null.sim2, i)
  }
}

########################################################
########### sim 2: supplementary
########################################################
######################################################################################
##############Simulation 2: Comparison with others methods############################
######################################################################################
set.seed(970912)
n.cluster <- c(3,5,30)
n.noisevar <- c(5,50,250,1000)
var <- 1
n.rep <- 20
n.validvar <- 50
nmu <- c(0.6,0.7,0.8,1)
con.rep <- 1:40
#condition1 <- expand.grid(nobs = n.obs, nnoisevar= n.noisevar, nmu = nmu, rep = con.rep)
condition1 <- expand.grid(ncluster = n.cluster, nnoisevar= n.noisevar, nvalidvar = n.validvar,
                          nmu = nmu, rep = con.rep)
setwd("E:/Users/u1275970/Documents/CKM/sim2")
#setwd("//tsclient/C/Users/Shuai Yuan/Documents/CKM_new/CKM_revision/sim1")
#setwd("C:/Users/Shuai Yuan/Documents/CKM_1/data analysis/sim2_add")
#setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim1.new")

# run the script with multi-core systems
no_cores <- 30
#no_cores <- 2
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
## from iteration 1576, we start recording the time
# to store the final results (including congruence between the simulation loading matrics, ARI of iCluster(which could already been obtained here),
# ARI of iCluster, and the congruence between obtained loading matrics and simulatd loading matrices)
sim1_data <- foreach(h = 1:nrow(condition1),
                     .packages = c("mclust", "combinat", "multichull",
                                   "sparcl",   "rARPACK", "Biobase", "CKM", "RSpectra", "cluster"
                     ), .combine=rbind) %dopar%{
                       
                       #time.start <- proc.time()
                       #if(!file.exists(paste0(h, ".RData"))){
                       #n.obs <- condition1$nobs[h]
                       n.cluster <- condition1$ncluster[h]
                       n.obs <- n.cluster * 50
                       n.noisevar <- condition1$nnoisevar[h]
                       mu <- condition1$nmu[h]
                       n.totalvar <- n.noisevar + n.validvar
                       records <- matrix(nrow = 3, ncol = 4)
                       
                       sim.data <- DataGenCKM(n.obs, n.cluster, n.validvar, n.noisevar, mu, var)
                       dataset <- sim.data[[1]]
                       cluster.assign <- sim.data[[2]]
                       valid.set <- 1:n.validvar
                       ##############################################
                       valid.set.test <- list()
                       ##############################################
                       prc1 <- proc.time()
                       results <- try(CKMSelVar(dataset, n.cluster))
                       
                       a <- proc.time() - prc1
                       if(inherits(results, "try-error"))
                       {
                         records[3,1] <- NA
                         records[2,1] <- NA
                         records[1,1] <- NA
                         valid.set.test[[1]] <- NA
                       }
                       if(!inherits(results, "try-error"))
                       {
                         records[3,1] <- a[1]
                         records[2,1] <- length(results$signaling.set)
                         records[1,1] <- classError(cluster.assign, results$cluster.assign)[[2]]
                         valid.set.test[[1]] <- results$signaling.set
                       }
                       
                       prc2 <- proc.time()
                       results.gss <- hill_climb_GSS(dataset, n.cluster, nperms=n.rep,itermax=500,threshold=0,tolerance=1)
                       a <- proc.time() - prc2
                       records[3,2] <- a[1]
                       records[2,2] <- length(results.gss$final_set)
                       records[1,2] <- classError(cluster.assign, results.gss$result)[[2]]
                       valid.set.test[[2]] <- results.gss$final_set
                       
                       ################################################
                       ############################################
                       prc4 <- proc.time()
                       kmeans.results <- kmeans(dataset, n.cluster, nstart = n.rep)
                       a <- proc.time() - prc4
                       records[3,4] <- a[1]
                       records[2,4] <- ncol(dataset)
                       records[1,4] <- classError(cluster.assign, kmeans.results$cluster)[[2]]
                       valid.set.test[[4]] <- 1:ncol(dataset)
                       ###########################################
                       #prc5 <- proc.time()
                       #results.rkm <- cluspca(dataset, n.cluster, n.cluster, alpha = NULL, method = "RKM")
                       #a <- proc.time() - prc5
                       #records[3,5] <- a[1]
                       #records[2,5] <- ncol(dataset)
                       #records[1,5] <- classError(cluster.assign, results.rkm$cluster)[[2]]
                       #valid.set.test[[5]] <- 1:ncol(dataset)
                       
                       results <- list(records = records, valid.set.test = valid.set.test, dataset = dataset)
                       
                       save(results, file = paste0(h, ".RData"))
                     }

stopCluster(c1)
###################################################

########################################################################################
##############Simulation 3: Selection of number of clusters ############################
########################################################################################
set.seed(970912)
n.cluster <- c(3,5)
n.obs <- 225
n.noisevar <- c(5, 25, 50, 100, 500, 1000)
var <- 1
n.validvar <- 50
maxclust <- 8

nmu <- c(0.6, 1)
con.rep <- 1:50
condition2 <- expand.grid(ncluster = n.cluster, nobs = n.obs, nnoisevar= n.noisevar, nmu = nmu, rep = con.rep)

setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim4.new")
#setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim2.new")
# run the script with multi-core systems
no_cores <- 3
#no_cores <- 2
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
## from iteration 1576, we start recording the time
# to store the final results (including congruence between the simulation loading matrics, ARI of iCluster(which could already been obtained here),
# ARI of iCluster, and the congruence between obtained loading matrics and simulatd loading matrices)
sim2_data <- foreach(h = 1:nrow(condition2),
                             .packages = c("mclust", "combinat",
                                           "sparcl",   "rARPACK", "Biobase", "clustrd", "CKM", "RSpectra", "cluster"
                             ), .combine=rbind) %dopar%{

                               #time.start <- proc.time()
                               #if(!file.exists(paste0(h, ".RData"))){
                               n.cluster <- condition2$ncluster[h]
                               n.obs <- condition2$nobs[h]
                               n.noisevar <- condition1$nnoisevar[h]
                               mu <- condition1$nmu[h]

                               records <- matrix(nrow = 4, ncol = 4)

                               #when varsplit = 1, half of the
                               sim.data <- DataGenCKM(n.obs, n.cluster, n.validvar, n.noisevar, mu, var)
                               dataset <- sim.data[[1]]
                               cluster.assign <- sim.data[[2]]
                               ##############################################
                               prc1 <- proc.time()
                               results <- CKMSelAll(dataset, maxclust)
                               a <- proc.time() - prc1
                               records[1,1] <- a[1]
                               records[1,2] <- results$opt.cluster
                               records[1,3] <- results$n.noisevar
                               records[1,4] <- classError(cluster.assign, results$cluster.assign)[[2]]

                               prc1 <- proc.time()
                               results <- CKMSelAll(dataset, maxclust, method = "firstmax")
                               a <- proc.time() - prc1
                               records[2,1] <- a[1]
                               records[2,2] <- results$opt.cluster
                               records[2,3] <- results$n.noisevar
                               records[2,4] <- classError(cluster.assign, results$cluster.assign)[[2]]

                               prc1 <- proc.time()
                               b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                               opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                               est.cluster.assign <- kmeans(dataset, centers = opt.cluster, nstart = 10)
                               a <- proc.time() - prc1
                               records[3,1] <- a[1]
                               records[3,2] <- opt.cluster
                               records[3,3] <- 0
                               records[3,4] <- classError(cluster.assign, est.cluster.assign)[[2]]

                               prc1 <- proc.time()
                               b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                               opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                               est.cluster.assign <- kmeans(dataset, centers = opt.cluster, nstart = 10)
                               a <- proc.time() - prc1
                               records[4,1] <- a[1]
                               records[4,2] <- opt.cluster
                               records[4,3] <- 0
                               records[4,4] <- classError(cluster.assign, est.cluster.assign)[[2]]

                               save(records, file = paste0(h, ".RData"))
                             }

stopCluster(c1)

###############################
### the simulation of model selection applied with SAS
### note the analysis on the full set only need to be conducted once
set.seed(970912)
n.cluster <- c(3,5)
n.obs <- 225
n.noisevar <- c(5, 25, 50, 100, 500, 1000)
var <- 1
n.validvar <- 50
maxclust <- 8
n.rep <- 20

nmu <- c(0.6, 1)
con.rep <- 1:50
condition2 <- expand.grid(ncluster = n.cluster, nobs = n.obs, nnoisevar= n.noisevar, nmu = nmu, rep = con.rep)

setwd("C:/Users/Shuai Yuan/Documents/CKM/sim3_1")
no_cores <- 3
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
sim2_data <- foreach(h = 1:nrow(condition2),
                     .packages = c("mclust", "combinat",
                                   "fpc",   "rARPACK", "CKM", "RSpectra", "cluster", "NbClust"
                     ), .combine=rbind) %dopar%{

                       n.cluster <- condition2$ncluster[h]
                       n.obs <- condition2$nobs[h]
                       n.noisevar <- condition2$nnoisevar[h]
                       mu <- condition2$nmu[h]

                       records <- matrix(nrow = 16, ncol = 2)
                       colnames(records) <- c("nselect", "nvalid")

                       ## data generation
                       sim.data <- DataGenCKM(n.obs, n.cluster, n.validvar, n.noisevar, mu, var)
                       dataset <- sim.data[[1]]
                       cluster.assign <- sim.data[[2]]

                       ## on the full datasets
                       # kl
                       results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "kl", alphaBeale = 0.1)
                       # best selected clusters
                       records[1,1] <- results$Best.nc[1]
                       # the number of noisy variabels
                       records[1,2] <- 50

                       # D indices
                       results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "dindex", alphaBeale = 0.1)
                       index <- results$All.index
                       index.dif <- rep(NA, (maxclust - 3))
                       for (i in 1:(maxclust - 3)){
                         index.dif[i] <- (index[i+2] - index[i+1]) / (index[i+1]-index[i])
                       }
                       records[2,1] <- which.min(index.dif) + 2
                       records[2,2] <- 50

                       # global max and first max
                       b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       records[3,1] <- opt.cluster
                       records[3,2] <- 50

                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                       records[4,1] <- opt.cluster
                       records[4,2] <- 50

                       ###### SAS

                       results.sel <- list()
                       partition.sel <- list()
                       ## number of variable selected (to be valid variables)
                       n.sel <- rep(NA, (maxclust - 1))
                       gap.sel <- rep(NA, (maxclust - 1))

                       for (i in 2:maxclust){
                         results.gss <- hill_climb_GSS(dataset, i, nperms=n.rep,itermax=20,threshold=0,tolerance=1)
                         results.sel[[(i-1)]] <- results.gss$final_set
                         partition.sel[[(i-1)]] <- results.gss$result
                         n.sel[(i-1)] <- results.gss$s
                         gap.sel[(i-1)] <- results.gss$gap
                       }

                       valid.set.all <- Reduce(intersect, results.sel)
                       new.data <- dataset[,valid.set.all]
                       b <- clusGap(new.data, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")

                       n_validvar <- n.sel[(opt.cluster - 1)]
                       signaling.set <- results.sel[[(opt.cluster - 1)]]
                       cluster.assign.test <- partition.sel[[(opt.cluster - 1)]]

                       records[5,1] <- opt.cluster
                       records[5,2] <- n_validvar

                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       n_validvar <- n.sel[(opt.cluster - 1)]

                       records[6,1] <- opt.cluster
                       records[6,2] <- n_validvar

                       ## the full datasets work for all methods
                       # kl
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "kl", alphaBeale = 0.1)
                       # best selected clusters
                       opt.cluster <- results$Best.nc[1]
                       records[7,1] <- opt.cluster
                       # the number of noisy variabels
                       records[7,2] <- n.sel[(opt.cluster - 1)]

                       # D indices
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "dindex", alphaBeale = 0.1)
                       index <- results$All.index
                       index.dif <- rep(NA, (maxclust - 3))
                       for (i in 1:(maxclust - 3)){
                         index.dif[i] <- (index[i+2] - index[i+1]) / (index[i+1]-index[i])
                       }
                       opt.cluster<- which.min(index.dif) + 2
                       records[8,1] <- opt.cluster
                       records[8,2] <- n.sel[(opt.cluster - 1)]

                       ## global maximum on all possible values of gap statistics
                       opt.cluster <- which(gap.sel == max(gap.sel, na.rm = TRUE))[1] + 1
                       # report the results
                       n_validvar <- n.sel[(opt.cluster - 1)]
                       records[9,1] <- opt.cluster
                       records[9,2] <- n_validvar

                       ## first maximum on all possible values of gap statistics
                       opt.cluster <- localMaxima(gap.sel)[1] + 1
                       # report the results
                       n_validvar <- n.sel[(opt.cluster - 1)]
                       records[10,1] <- opt.cluster
                       records[10,2] <- n_validvar

                       ### CKM

                       results <- CKMSelAll(dataset, maxclust)

                       records[11,1] <- results$opt.cluster
                       records[11,2] <- results

                       prc1 <- proc.time()
                       results <- CKMSelAll_a(dataset, maxclust, method = "firstmax")
                       a <- proc.time() - prc1
                       records[2,1] <- a[1]
                       records[2,2] <- results$opt.cluster
                       records[2,3] <- results$n.noisevar
                       records[2,4] <- classError(cluster.assign, results$cluster.assign)[[2]]

                       prc1 <- proc.time()
                       b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       est.cluster.assign <- kmeans(dataset, centers = opt.cluster, nstart = 10)
                       a <- proc.time() - prc1
                       records[3,1] <- a[1]
                       records[3,2] <- opt.cluster
                       records[3,3] <- 0
                       records[3,4] <- classError(cluster.assign, est.cluster.assign)[[2]]

                       prc1 <- proc.time()
                       b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                       est.cluster.assign <- kmeans(dataset, centers = opt.cluster, nstart = 10)
                       a <- proc.time() - prc1
                       records[4,1] <- a[1]
                       records[4,2] <- opt.cluster
                       records[4,3] <- 0
                       records[4,4] <- classError(cluster.assign, est.cluster.assign)[[2]]

                       ### model selection with SAS
                       #### approach 1: the selection with a subset and
                       results.sel <- list()
                       partition.sel <- list()
                       ## number of variable selected (to be valid variables)
                       n.sel <- rep(NA, (maxclust - 1))
                       gap.sel <- rep(NA, (maxclust - 1))

                       for (i in 2:maxclust){
                         results.gss <- hill_climb_GSS(dataset, i, nperms=n.rep,itermax=20,threshold=0,tolerance=1)
                         results.sel[[(i-1)]] <- results.gss$final_set
                         partition.sel[[(i-1)]] <- results.gss$result
                         n.sel[(i-1)] <- results.gss$s
                         gap.sel[(i-1)] <- results.gss$gap
                       }

                       valid.set.all <- Reduce(intersect, results.sel)
                       new.data <- dataset[,valid.set.all]
                       b <- clusGap(new.data, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")

                       n_validvar <- n.sel[(opt.cluster - 1)]
                       signaling.set <- results.sel[[(opt.cluster - 1)]]
                       cluster.assign.test <- partition.sel[[(opt.cluster - 1)]]

                       records[1,1] <- opt.cluster
                       records[1,2] <- n_validvar
                       records[1,3] <- classError(cluster.assign, cluster.assign.test)[[2]]

                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       n_validvar <- n.sel[(opt.cluster - 1)]
                       signaling.set <- results.sel[[(opt.cluster - 1)]]
                       cluster.assign.test <- partition.sel[[(opt.cluster - 1)]]

                       records[2,1] <- opt.cluster
                       records[2,2] <- n_validvar
                       records[2,3] <- classError(cluster.assign, cluster.assign.test)[[2]]

                       ## the full datasets work for all methods
                       b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       est.cluster.assign <- kmeans(dataset, centers = opt.cluster, nstart = 10)

                       records[3,1] <- opt.cluster
                       records[3,2] <- n.noisevar + n.validvar
                       records[3,3] <- classError(cluster.assign, est.cluster.assign$cluster)[[2]]

                       b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                       est.cluster.assign <- kmeans(dataset, centers = opt.cluster, nstart = 10)

                       records[4,1] <- opt.cluster
                       records[4,2] <- n.noisevar + n.validvar
                       records[4,3] <- classError(cluster.assign, est.cluster.assign$cluster)[[2]]

                       ## the cluster selection based on the optimal gap statistic value of each cluster
                       ## global maximum
                       opt.cluster <- which(gap.sel == max(gap.sel, na.rm = TRUE))[1] + 1
                       # report the results
                       n_validvar <- n.sel[(opt.cluster - 1)]
                       signaling.set <- results.sel[[(opt.cluster - 1)]]
                       cluster.assign.test <- partition.sel[[(opt.cluster - 1)]]

                       records[5,1] <- opt.cluster
                       records[5,2] <- n_validvar
                       records[5,3] <- classError(cluster.assign, cluster.assign.test)[[2]]

                       ## first maximum
                       opt.cluster <- localMaxima(gap.sel)[1] + 1
                       # report the results
                       n_validvar <- n.sel[(opt.cluster - 1)]
                       signaling.set <- results.sel[[(opt.cluster - 1)]]
                       cluster.assign.test <- partition.sel[[(opt.cluster - 1)]]

                       records[6,1] <- opt.cluster
                       records[6,2] <- n_validvar
                       records[6,3] <- classError(cluster.assign, cluster.assign.test)[[2]]

                       save(records, file = paste0(h, ".RData"))
                     }

stopCluster(c1)

###############################
### the simulation of model selection applied with SKM

prc3 <- proc.time()
permute.method <- try(KMeansSparseCluster.permute(dataset, K = n.cluster, wbounds = seq(1.001,10,len= 100), nperms=n.rep))
a <- proc.time() - prc3
records[3,3] <- a[1]
if(inherits(permute.method, "try-error"))
{
  records[3,3] <- NA
  records[2,3] <- NA
  records[1,3] <- NA
  valid.set.test[[3]] <- NA
}
if(!inherits(permute.method, "try-error"))
{
  max.gap <- max(permute.method$gaps)
  max.gap.sd <- permute.method$sdgaps[which(permute.method$gaps == max.gap)[1]]
  gap.crit <- max.gap - max.gap.sd
  wbound.opt <- permute.method$wbounds[sort(which(permute.method$gaps < gap.crit), decreasing = TRUE)[1]]
  result.method1 <- KMeansSparseCluster(dataset, K = n.cluster, wbounds = wbound.opt, nstart = 1000)
  records[2,3] <- length(which(result.method1[[1]]$ws != 0))
  records[1,3] <- classError(cluster.assign, result.method1[[1]]$Cs)[[2]]
  valid.set.test[[3]] <- which(result.method1[[1]]$ws != 0)
}

########################################################################################
##############Simulation 4: Selection of number of clusters ############################
########################################################################################
set.seed(970912)
n.cluster <- c(3,5)
n.obs <- 225
n.noisevar <- c(5, 25, 50, 100, 500, 1000)
var <- 1
n.validvar <- 50
maxclust <- 8

nmu <- c(0.6, 1)
con.rep <- 1:50
condition2 <- expand.grid(ncluster = n.cluster, nobs = n.obs, nnoisevar= n.noisevar, nmu = nmu, rep = con.rep)

setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim4.new")
files <- NA
for (i in 1:nrow(condition2)){
  if(!file.exists(paste0(i,".RData"))){
    files <- c(i, files)
  }
}
#setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim2.new")
# run the script with multi-core systems
no_cores <- 3
#no_cores <- 2
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
## from iteration 1576, we start recording the time
# to store the final results (including congruence between the simulation loading matrics, ARI of iCluster(which could already been obtained here),
# ARI of iCluster, and the congruence between obtained loading matrics and simulatd loading matrices)
sim2_data <- foreach(h = files,
                     .packages = c("mclust", "combinat",
                                   "fpc",   "rARPACK", "CKM", "RSpectra", "cluster", "NbClust"
                     ), .combine=rbind) %dopar%{

                       #time.start <- proc.time()
                       #if(!file.exists(paste0(h, ".RData"))){
                       n.cluster <- condition2$ncluster[h]
                       n.obs <- condition2$nobs[h]
                       n.noisevar <- condition2$nnoisevar[h]
                       mu <- condition2$nmu[h]

                       records <- matrix(nrow = 16, ncol = 2)

                       #when varsplit = 1, half of the
                       sim.data <- DataGenCKM(n.obs, n.cluster, n.validvar, n.noisevar, mu, var)
                       dataset <- sim.data[[1]]
                       cluster.assign <- sim.data[[2]]
                       ##############################################
                       # global
                       results <- CKMSelAll_a(dataset, maxclust)
                       signaling.set <- results$stable.set
                       records[1,1] <- results$opt.cluster
                       records[1,2] <- classError(cluster.assign, results$cluster.assign)[[2]]
                       new.data <- dataset[,signaling.set]
                       b <- results$b

                       # first
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                       est.cluster.assign <- kmeans(new.data, centers = opt.cluster, nstart = 10)
                       records[2,1] <- opt.cluster
                       records[2,2] <- classError(cluster.assign, est.cluster.assign)[[2]]

                       # Nbclust
                       # kl
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                               method = "kmeans", index = "kl", alphaBeale = 0.1)
                       records[3,1] <- results$Best.nc[1]
                       records[3,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # marriot
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "marriot", alphaBeale = 0.1)
                       records[4,1] <- results$Best.nc[1]
                       records[4,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # TraceW
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "tracew", alphaBeale = 0.1)
                       records[5,1] <- results$Best.nc[1]
                       records[5,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # silhouette
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "silhouette", alphaBeale = 0.1)
                       records[6,1] <- results$Best.nc[1]
                       records[6,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # dindex
                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "dindex", alphaBeale = 0.1)
                       index <- results$All.index
                       index.dif <- rep(NA, (maxclust - 3))
                       for (i in 1:(maxclust - 3)){
                         index.dif[i] <- (index[i+2] - index[i+1]) / (index[i+1]-index[i])
                       }
                       records[7,1] <- which.min(index.dif) + 2

                       # bootstrapping
                       results <- nselectboot(new.data, B = 300, clustermethod = kmeansCBI, krange = 2:maxclust)
                       records[8,1] <- results$kopt

                       ################################# the full datasets
                       b <- clusGap(dataset, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       records[9,1] <- opt.cluster

                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                       records[10,1] <- opt.cluster

                       # Nbclust
                       # kl
                       results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "kl", alphaBeale = 0.1)
                       records[11,1] <- results$Best.nc[1]
                       records[11,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # marriot
                       #results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          #method = "kmeans", index = "marriot", alphaBeale = 0.1)
                       #records[12,1] <- results$Best.nc[1]
                       #records[12,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # TraceW
                       #results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                        #                  method = "kmeans", index = "tracew", alphaBeale = 0.1)
                       #records[13,1] <- results$Best.nc[1]
                       #records[13,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # silhouette
                       results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "silhouette", alphaBeale = 0.1)
                       records[14,1] <- results$Best.nc[1]
                       records[14,2] <- classError(cluster.assign, results$Best.partition)[[2]]

                       # dindex
                       results <- NbClust(dataset, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "dindex", alphaBeale = 0.1)
                       index <- results$All.index
                       index.dif <- rep(NA, (maxclust - 3))
                       for (i in 1:(maxclust - 3)){
                         index.dif[i] <- (index[i+2] - index[i+1]) / (index[i+1]-index[i])
                       }
                       records[15,1] <- which.min(index.dif) + 2

                       # bootstrapping
                       results <- nselectboot(dataset, B = 100, clustermethod = kmeansCBI, krange = 2:maxclust)
                       records[16,1] <- results$kopt

                       analysis.results <- list(records = records, dataset = dataset, signaling.set = signaling.set)
                       save(analysis.results, file = paste0(h, ".RData"))
                     }

stopCluster(c1)



## additional check
condition2 <- expand.grid(ncluster = n.cluster, nobs = n.obs, nnoisevar= n.noisevar, nmu = nmu, rep = con.rep)
maxclust <- 8
setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim4.new")
#setwd("C:/Users/u1275970/Documents/JCDR/CKM/sim2.new")
# run the script with multi-core systems
no_cores <- 3
#no_cores <- 2
c1 <- makePSOCKcluster(no_cores)
registerDoParallel(c1)
## from iteration 1576, we start recording the time
# to store the final results (including congruence between the simulation loading matrics, ARI of iCluster(which could already been obtained here),
# ARI of iCluster, and the congruence between obtained loading matrics and simulatd loading matrices)
sim2_data <- foreach(h = 1:nrow(condition2),
                     .packages = c("mclust", "combinat",
                                   "fpc",   "rARPACK", "CKM", "RSpectra", "cluster", "NbClust"
                     ), .combine=rbind) %dopar%{

                       load(paste0(h, ".RData"))

                       old.data <- analysis.results$dataset
                       sig.var <- analysis.results$signaling.set
                       new.data <- old.data[,sig.var]

                       records <- rep(NA, 4)

                       b <- clusGap(new.data, FUN=kmeans, K.max=maxclust, B=500, spaceH0 = "original")
                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "globalmax")
                       records[1] <- opt.cluster

                       opt.cluster <- maxSE(b$Tab[,3], b$Tab[,4], method = "firstmax")
                       records[2] <- opt.cluster

                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "kl", alphaBeale = 0.1)
                       records[3] <- results$Best.nc[1]

                       results <- NbClust(new.data, diss = NULL, distance = "euclidean", min.nc = 2, max.nc = maxclust,
                                          method = "kmeans", index = "dindex", alphaBeale = 0.1)
                       index <- results$All.index
                       index.dif <- rep(NA, (maxclust - 3))
                       for (i in 1:(maxclust - 3)){
                         index.dif[i] <- (index[i+2] - index[i+1]) / (index[i+1]-index[i])
                       }
                       records[4] <- which.min(index.dif) + 2

                       save(records, file = paste0(h,"a",".RData"))
                     }
stopCluster(c1)




